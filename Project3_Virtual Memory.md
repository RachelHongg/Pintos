# Introduction
    
    지금쯤이면 핀토스의 내부 작동 방식에 어느 정도 익숙해졌을 것입니다. OS는 적절한 동기화를 통해 여러 실행 스레드를 적절히 처리할 수 있으며, 여러 사용자 프로그램을 한 번에 로드할 수 있습니다. 그러나 실행할 수 있는 프로그램의 수와 크기는 컴퓨터의 주 메모리 크기에 의해 제한됩니다. 이 과제에서는 **무한한 메모리라는 환상**을 구축하여 이러한 제한을 제거합니다.
    
    이 과제는 지난 과제 위에 구축할 것입니다. 프로젝트 2의 테스트 프로그램은 프로젝트 3에서도 작동해야 합니다. 프로젝트 2 제출물의 버그는 프로젝트 3에서도 동일한 문제를 일으킬 가능성이 높으므로 프로젝트 3 작업을 시작하기 전에 프로젝트 2 제출물의 모든 버그를 수정해야 합니다.
    
    프로젝트 3의 경우 여러분의 편의를 위해 단계별 지침을 제공합니다.
    
    ## 배경
        ### 소스 파일
            
            이 프로젝트의 `vm` 디렉토리에서 작업하게 됩니다. `Makefile`을 업데이트하여 `-DVM` 설정을 켭니다. 방대한 양의 템플릿 코드를 제공합니다. 
            
            반드시 주어진 템플릿을 따라야 합니다. 즉, 주어진 템플릿에 기반하지 않은 코드를 제출하면 0점을 받습니다. 또한 "변경하지 마세요"라고 표시된 템플릿은 절대로 변경해서는 안 됩니다. 
            
            #### `include/vm/vm.h`, `vm/vm.c`
                
                ![스크린샷 2023-12-25 오후 3.20.34.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b278eae5-15fb-42de-a493-229718a0b327/f3b48d32-0268-42a4-b7fe-ad06093a67ba/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-12-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.20.34.png)
                
            #### vm_type(가상 메모리 타입)
                - `VM_ANON`(파일과 relate 되지 않은 페이지, anonymous page)
                - `VM_PAGE_CACHE`(페이지 캐시를 가진 페이지)
                    - 프로젝트 4용이므로, 3에서는 무시하기
                - `VM_FILE`(파일과 relate 된 페이지)
                - `VM_UNINIT`(초기화 되지 않은 페이지)
            #### `include/vm/uninit.h`, `vm/uninit.c`
                - 초기화되지 않은 페이지에 대한 작업을 제공합니다(vm_type = `VM_UNINIT`).
                - 현재 설계에서는, 모든 페이지가 처음에 초기화되지 않은 페이지로 설정되고, 익명 페이지(anonymous pages) 또는 파일 백업 페이지(file backed pages)로 변환됩니다.
            #### `include/vm/anon.h`, `vm/anon.c`
                - 익명 페이지(anonymous pages)에 대한 작업을 제공합니다(vm_type = `VM_ANON`).
            #### `include/vm/file.h`, `vm/file.c`
                - 파일 지원 페이지에 대한 작업을 제공합니다(vm_type = `VM_FILE`).
            #### `includew/vm/inspect.h`, `vm/inspect.c`
                - 채점을 위한 메모리 검사 연산을 포함합니다.
                - 이 파일은 **변경하지 마세요.**
            #### `include/devices/block.h`, `devices/block.c`
                - 블록 장치에 대한 섹터 기반 읽기 및 쓰기 액세스를 제공합니다. 이 인터페이스를 사용하여 블록 장치로 **스왑 파티션**에 액세스합니다.
                - `include/devices/block.h`, `devices/block.c` 로 봐야한다.(git book manual이 업데이트 안되어 있는듯)
        ### Memory 용어
            
            먼저 메모리와 스토리지에 대한 몇 가지 용어를 소개합니다. 이 용어 중 일부는 프로젝트 2([가상 메모리 레이아웃](https://www.notion.so/KAIST-PintOS-Assignment-fa08d9c1fc8e430f9496de59a3ae8e2c?pvs=21) 참조)에서 익숙한 것이지만 대부분은 새로운 용어입니다.
            
            #### Pages
                
                ‘가상 페이지(virtual page)’라고도 하는 ‘페이지(page)’는 길이가 4,096바이트(=4KB =***page size***)인 가상 메모리의 연속적인 영역입니다. 
                
                페이지는 페이지 정렬(**page-aligned**), 즉. 페이지 크기(=4KB)로 균등하게 나눌 수 있는 가상 주소에서 시작해야 합니다. 따라서, **64비트 가상 주소의 마지막 12비트**는 페이지 오프셋(***page offset***, 또는 그냥 오프셋 ***offset***)입니다. 
                
                → 페이지 크기가 4096바이트이므로, 2**12는 4096이 된다.
                
                상위 비트는 곧 도입될 페이지 테이블의 인덱스를 나타내는 데 사용됩니다. 64비트 시스템에서는 4단계 페이지 테이블을 사용하므로 가상 주소는 다음과 같이 보입니다:
                
                `
                63          48 47            39 38            30 29            21 20         12 11         0
                +-------------+----------------+----------------+----------------+-------------+------------+
                | Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |    Page    |
                |             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
                +-------------+----------------+----------------+----------------+-------------+------------+
                              |                |                |                |             |            |
                              +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                                          Virtual Address
                `
                
                각 프로세스에는 독립적인 사용자(가상) 페이지 세트가 있으며, 이 페이지는 가상 주소 `KERN_BASE`(0x8004000000) 아래에 있는 페이지입니다. 반면 ***커널(가상) 페이지*** 세트는 전역이므로 실행 중인 스레드나 프로세스에 관계없이 동일한 위치에 유지됩니다. 커널은 사용자 페이지와 커널 페이지 모두에 액세스할 수 있지만 사용자 프로세스는 자신의 사용자 페이지에만 액세스할 수 있습니다. 자세한 내용은 [가상 메모리 레이아웃](https://www.notion.so/KAIST-PintOS-Assignment-fa08d9c1fc8e430f9496de59a3ae8e2c?pvs=21)을 참조하세요.
                
                - 유저 가상 메모리 VS 커널 가상 메모리
                    
                    1) 유저 가상 메모리
                    
                    1-1) 영역: 0 ~ KERN_BASE
                    
                    1-2) 하나의 프로세스는 하나의 사용자 가상 메모리를 가진다
                    
                    → thread 구조체는 각각의 프로세스의 페이지 테이블(page table)을 가리키는 포인터를 가지고 있다 (`*pml4`)
                    
                    → 프로세스 문맥교환 일어날때 커널은 프로세스의 ‘page directory base register’( see `pml4_activate()` in `thread/mm.c`)를 바꿈으로써 유저 가상 공간 또한 바꿔준다.
                    
                    ![스크린샷 2023-12-25 오후 3.57.39.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b278eae5-15fb-42de-a493-229718a0b327/33672318-ebfe-47ff-98af-9d7fb82e68b0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-12-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.57.39.png)
                    
                    2) 커널 가상 메모리
                    
                    2-1) 영역: KERN_BASE ~ 
                    
                    2-2) 커널 가상 메모리는 전역적이다
                    
                    → 어떠한 유저 프로세스나 커널 스레드가 CPU 제어권을 획득해 running인지 관계없이 항상 같은 방식으로 매핑된다.(모든 유저 프로세스 VM의 Kernel VM은 항상 동일하다.)
                    
                    → 핀토스에서는 `KERN_BASE` 에서 시작하는 커널 가상 메모리는 물리 메모리와 일대일 매핑이 된다. 다시 말해, 가상 주소인 KERN_BASE는 물리주소 0에 매핑되고, 가상 주소 `KERN_BASE` + `0x1234` 물리주소 `0x1234`에 매핑된다
                    
                - 페이지 폴트(Page Fault)가 나는 이유?
                    - `userprog/exception.c` 에 있는 `page_fault()` 라는 함수에 의해 이루어짐.
                    - page fault가 일어나는 이유?
                        - 유저 프로그램이 커널 가상 메모리에 접근하려고 할 때
                        - 커널에서 매핑되지 않은 유저 가상 주소를 접근하려고 할 때
                    - 한편, 커널 스레드들은 커널 가상 메모리에 접근 가능하고 만일 유저 프로세스가 running 상태라면 이 유저 프로세스의 유저 가상 메모리에도 접근할 수 있다
                - `rsp` VS `rip`
                    
                    ![스크린샷 2023-12-25 오후 4.59.06.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b278eae5-15fb-42de-a493-229718a0b327/00c78227-f5ee-4ead-bfc0-d85229ba7486/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-12-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.59.06.png)
                    
                    - `rsp`: stack의 시작주소를 가리키는 포인터
                    - `rip`: 현재 수행주인 명령어(instruction) 코드를 가리키는 레지스터(포인터)
                
                핀토스는 **가상 주소 작업에 유용한 몇 가지 함수**를 제공합니다. 자세한 내용은 가상 주소 섹션을 참조하십시오.
                
            #### Frames
                
                ***물리적 프레임*** 또는 ***페이지 프레임***이라고도 하는 ***프레임***은 물리적 메모리의 연속적인 영역입니다. (물리 메모리 자체는 연속적이지 않지만, 물리 프레임은 연속적이다.) 페이지와 마찬가지로 프레임도 페이지 크기와 페이지 정렬을 유지해야 합니다. 따라서 64비트 물리적 주소는 다음과 같이 ***프레임 번호***와 ***프레임 오프셋***(또는 그냥 ***오프셋***)으로 나눌 수 있습니다:
                
                `
                                          12 11         0
                    +-----------------------+-----------+
                    |      Frame Number     |   Offset  |
                    +-----------------------+-----------+
                              Physical Address
                `
                
                **x86-64는 물리적 주소의 메모리에 직접 액세스할 수 있는 방법을 제공하지 않습니다. 핀토스는 커널 가상 메모리를 물리적 메모리에 직접 매핑하여 이 문제를 해결**합니다. 커널 가상 메모리의 첫 번째 페이지는 물리적 메모리의 첫 번째 프레임에, 두 번째 페이지는 두 번째 프레임에 매핑하는 식으로 말이죠. 따라서 **커널 가상 메모리를 통해 프레임에 액세스할 수 있습니다**.
                
                핀토스는 물리적 주소와 커널 가상 주소 사이를 변환하는 기능을 제공합니다. 자세한 내용은 가상 주소(Appendix)를 참조하십시오.
                
                - `ptov` : physical to virtual
                - `vtop` : virtual to physical
            #### Page Tables
                
                ***페이지 테이블***은 CPU가 가상 주소를 물리적 주소로, 즉 페이지에서 프레임으로 변환하는 데 사용하는 데이터 구조입니다.(page → frame) 페이지 테이블 형식은 x86-64 아키텍처에 의해 결정됩니다. 핀토스는 `threads/mmu.c`에서 페이지 테이블 관리 코드를 제공합니다.
                
                아래 다이어그램은 페이지와 프레임 간의 관계를 보여줍니다. 왼쪽의 가상 주소는 페이지 번호와 오프셋으로 구성됩니다. 페이지 테이블은 페이지 번호를 프레임 번호로 변환하고, 수정되지 않은 오프셋과 결합하여 오른쪽의 물리적 주소를 얻습니다.
                
                `
                                          +----------+
                         .--------------->|Page Table|-----------.
                        /                 +----------+            |
                        |   12 11 0                               V  12 11 0
                    +---------+----+                         +---------+----+
                    | Page Nr | Ofs|                         |Frame Nr | Ofs|
                    +---------+----+                         +---------+----+
                     Virt Addr   |                            Phys Addr    ^
                                  \_______________________________________/
                `
                
                페이지 테이블은 CPU가 가상 주소를 실제 주소로, 즉 페이지에서 프레임으로 변환하는 데 사용하는 데이터 구조입니다. 페이지 테이블 형식은 x86-64 아키텍처에 의해 결정됩니다. 핀토스는 `threads/mmu.c` 에서 페이지 테이블 관리 코드를 제공합니다.
                
                - 운영체제 책 p199)
                    - 각 프로세스의 물리 메모리에 상주, 운영체제 메모리 영역에 페이지 테이블이 존재한다고 당분간 가정
                    - 추가) Supplemental Page Table는 물리 메모리에 존재하는 페이지 테이블(Page Table)과 달리, 가상 메모리의 일부로 존재
            #### Swap Slots
                
                **스왑 슬롯(swap slots)**은 스왑 파티션에 있는 디스크 공간의 페이지 크기 영역입니다. → swap은 disk의 한 영역 
                
                하드웨어적 제한들로 인해 배치가 제한되는 것(정렬)이 프레임에서보단 슬롯에서 더 유연한 편이지만, 정렬한다고 해서 부정적인 영향이 생기는 것이 아니기때문에, 스왑 슬록은 페이지 크기에 정렬하는 것이 좋다.
                
        ### 리소스 관리 개요
            
            다음 데이터 구조를 설계/구현해야 합니다:
            
            - Supplemental page table(보충 페이지 테이블)
            
            > 페이지 테이블을 보완하여 **페이지 오류 처리**를 활성화합니다. 아래의 보충 페이지 테이블 관리를 참조하세요.
            > 
            
            - Frame table
            
            > 물리적 프레임의 **퇴출(eviction) 정책**을 효율적으로 구현할 수 있습니다. 아래 프레임 테이블 관리하기를 참조하세요.
            > 
            
            - Swap table
            
            > 스왑 슬롯의 사용량을 추적합니다. 아래의 스왑 테이블 관리하기를 참조하세요.
            > 
            
            완전히 다른 세 가지 데이터 구조를 구현할 필요는 없습니다. 관련 리소스를 전체 또는 부분적으로 통합 데이터 구조(unified data structure)로 병합하는 것이 편리할 수 있습니다.
            
            **각 데이터 구조에 대해 각 요소에 어떤 정보가 포함되어야 하는지** 결정해야 합니다. 또한 데이터 구조의 범위를 로컬(프로세스 별) 또는 전역(전체 시스템에 적용)으로 결정하고 해당 범위 내에서 **필요한 인스턴스 수를 결정**해야 합니다.
            
            설계를 단순화하기 위해 이러한 데이터 구조를 페이지화할 수 없는 메모리(non pageable memory) (예: `calloc` 또는 `malloc`으로 할당된 메모리)에 저장할 수 있습니다. 즉, 이러한 데이터 구조 사이의 포인터가 유효하게 유지된다는 것을 확신할 수 있습니다.
            
            - 구현 선택 사항(성능 관점)
                
                **배열, 리스트, 비트맵, 해시 테이블**을 구현할 때 선택할 수 있는 방법에는 배열, 리스트, 비트맵, 해시 테이블이 있습니다. **배열**은 가장 간단한 접근 방식인 경우가 많지만, 빈도가 낮은(sparsely populated) 배열은 메모리를 낭비합니다. **리스트**도 간단하지만 특정 위치를 찾기 위해 긴 목록을 탐색하면 시간이 낭비됩니다. 배열과 리스트 모두 크기를 조정할 수 있지만 리스트가 중간에 삽입과 삭제를 더 효율적으로 지원합니다.
                
                핀토스는 `lib/kernel/bitmap.c`와 `include/lib/kernel/bitmap.h`에 비트맵 데이터 구조를 포함하고 있습니다. **비트맵**은 비트의 배열로, 각 비트는 참 또는 거짓일 수 있습니다. 비트맵은 일반적으로 (동일한) 리소스 집합의 사용량을 추적하는 데 사용됩니다. 리소스 n이 사용 중이면 비트맵의 비트 n은 참입니다. 핀토스 비트맵은 크기가 고정되어 있지만 크기 조정을 지원하도록 구현을 확장할 수 있습니다.
                
                핀토스에는 **해시 테이블** 데이터 구조도 포함되어 있습니다(해시 테이블 참조). 핀토스 해시 테이블은 다양한 테이블 크기에 걸쳐 삽입과 삭제를 효율적으로 지원합니다.
                
                더 복잡한 데이터 구조는 더 나은 성능이나 기타 이점을 제공할 수 있지만, 구현을 불필요하게 복잡하게 만들 수도 있습니다. 따라서 설계의 일부로 고급 데이터 구조(예: 균형 잡힌 이진 트리)를 구현하는 것은 권장하지 않습니다.
                
        ### Supplemental Page Table 관리하기
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b278eae5-15fb-42de-a493-229718a0b327/eba05026-26af-4237-bcbc-a1f07386d534/Untitled.png)
            
            ***보충(supplemental)*** 페이지 테이블이란?
            
            - **각 페이지에 대한 추가 데이터**로 page table을 보완
            - **페이지 테이블의 형식에 따른 제한 때문에 필요**합니다. 이러한 데이터 구조 역시 "페이지 테이블"이라고도 불리며, 혼동을 줄이기 위해 "***(supplemental)보충***"이라는 단어를 추가합니다.
            
            Supplemental Page Table(SPT)
            
            - page fault가 발생하면 커널이 SPT에서 오류가 발생한 가상 Page를 조회하여 거기에 어떤 데이터가 있어야 하는지 알아내는 것
            - Process가 종료될 때, kernel이 SPT을 참조하여 어떤 resource를 free할지 결정
            - 보충 페이지 테이블 구성
                
                보충 페이지 테이블은 원하는 대로 구성할 수 있습니다. 구성에서는 두가지 접근 방식이 있습니다.  세그먼트 기반 방식과 **페이지** 기반 방식이 있다. 
                
                여기서 세그먼트는 연속된 페이지 그룹, 즉 **실행 파일 또는 메모리 매핑 파일이 포함된 메모리 영역**을 의미합니다.
                
                **선택적으로**, 페이지 테이블 자체를 사용하여 보조 페이지 테이블의 구성원을 추적할 수 있습니다. 이렇게 하려면 `threads/mmu.c`에서 핀토스 페이지 테이블 구현을 수정해야 합니다. 이 접근 방식은 **고급(advanced) 학생에게만 권장**합니다.
                
            - Handling page fault
                - 보충 페이지 테이블의 핵심 유저는 **page fault handler**
                - 프로젝트 2에서 page fault는 항상 커널이나 사용자 프로그램의 버그를 의미
                - 프로젝트 3에서는 더 이상 그렇지 않습니다. 이제 page fault는 **파일 또는 스왑 슬롯에서 페이지를 가져와야 함**을 나타냄
                - 이러한 경우를 처리하려면 보다 정교한 page fault handler를 구현해야 합니다.
                - `userprog/exception.c`의 page fault handler `page_fault()`는 당신의 page fault handler `vm/vm.c` 인 `vm_try_handle_fault()`를 호출합니다.
                
                page fault handler는 대략 다음과 같은 작업을 수행해야 합니다:
                
                1. SPT(Supplemental Page Table)에서 페이지 폴트가 발생한 페이지를 찾는다. 메모리 참조가 유효하면 SPTE(SPT Entry)를 사용해서 페이지에 들어갈 데이터를 찾는다.
                    1. 데이터는 파일 시스템이나 스왑 슬롯에 있거나 단순히 0으로만 이루어진 페이지(all-zero 페이지)일 수 있다. 
                    2. 만약, 공유(즉, 쓰기 시 복사;copy-on-write)를 구현하는 경우 페이지의 데이터가 이미 ‘페이지 프레임’에 있지만 ‘페이지 테이블’에는 없을 수도 있습니다.
                    3. 만약 SPT이 다음과 같은 정보를 보여주고 있다면, 그 접근은 유효하지 않은 접근이다.  → 유효하지 않은 액세스는 프로세스를 종료하여 모든 리소스를 해제한다.
                        1. 유저 프로세스가 접근하여는 주소에 **데이터를 기대해서는 안 된다고 표시(indicate)**
                        2.  페이지가 커널 가상 메모리 내에 있는 경우
                        3. 액세스가 읽기 전용 페이지에 쓰려는 시도인 경우
                2. **페이지를 저장할 프레임을 가져옵니다(obtain)**. 
                    1. 공유를 구현하는 경우 필요한 데이터가 이미 프레임에 있을 수 있으며, 이 경우 해당 프레임을 찾을 수 있어야 합니다.
                3. **파일 시스템**이나 **스왑**에서 데이터를 읽거나 **0으로 설정**하는 등의 방법으로 데이터를 프레임으로 가져옵니다(fetching).
                    1.  공유를 구현하는 경우 필요한 페이지가 이미 프레임에 있을 수 있으며, 이 경우 이 단계에서는 아무런 작업이 필요하지 않습니다.
                4. 페이지 폴트가 발생한 가상 주소에 대한 페이지 엔트리(PTE)가 물리 페이지를 가리키도록 지정한다. `threads/mmu.c`의 함수를 사용할 수 있습니다.
                
                <aside>
                🤍 서누 추가
                1) 메모리 참조가 유효 
                → 스택과 힙이 충분히 자라지 않은 경우, 스택과 힙 사이에는 사용되지 않는 영역들이 존재
                → 사용되지 않는 영역을 참조하는 경우 ‘메모리가 유효하지 않다’고 표현
                
                2) 유저 가상 메모리는 heap이 아래에서 위로, stack이 위에서 아래로
                
                3) Copy-on-Write이 메모리는 공유된 메모리이기에, 부모든 자식이든 쓰기를 하게 되면 나머지 프로세스에도 영향이 가게 된다. 따라서 fork를 하게 되면 고유된 해당 메모리에 대해 자식과 부모 모두 쓰기 권한이 무효화된다. 이렇게 쓰기를 하려고 할 때, 물리 메모리 복사되는 상황을 ‘쓰기 시 복사’or copy-on-write이라 한다.
                
                4) 따라서 이 메모리에 쓰기 접근을 하면 페이지 폴트가 발생한다. 페이지 폴트 핸들러는 이 페이지를 다른 장소에 복사한 후에, 쓰기를 시도한 프로세스에 할당한 후, 내용을 다시 작성한다. 이제, 부모, 자식의 페이지 엔트리의 내용이 업데이트되고 쓰기 권한도 다시 생겨난다.
                
                5) fork()를 하면 자식에게 메모리 자체가 아닌 페이지 테이블만 복사하기 때문에 실제 물리 메모리를 자식과 부모가 공유하게 된다.
                
                </aside>
                
            
        ### Frame Table 관리
            - 현재 사용 중인 frame을 관리하기 위한 table
            - 프레임 테이블은 각 프레임의 엔트리 정보가 담겨있다
            - 물리 프레임의 방출 정책(eviction policy)를 구현하는 것을 가능케한다.
            
            프레임 테이블에는 각 프레임에 대해 하나의 항목(entry)이 포함됩니다. 프레임 테이블의 각 항목에는 **현재 해당 항목을 차지하고 있는 페이지**(있는 경우)에 대한 포인터와 **원하는 기타 데이터가 포함**되어 있습니다. 핀토스는 **프레임 테이블**을 사용하여 **빈 프레임이 없을 때 퇴거(eviction)할 페이지를 선택함으로써 퇴거 정책을 효율적으로 구현**할 수 있습니다.
            
            사용자 페이지에 사용되는 프레임은 `palloc_get_page(PAL_USER)`를 호출하여 'user_pool'에서 가져와야 합니다. 일부 테스트 케이스가 예기치 않게 실패할 수 있는 “kernel_pool"에서 할당하는 것을 피하려면 `PAL_USER`를 사용해야 합니다.(enum palloc_flag의 일종) 프레임 테이블 구현의 일부로 `palloc.c`를 수정하는 경우 두 풀의 구분을 유지해야 합니다.
            
            → PAL_USER 써서 kernel pool에서 가져오는 상황 방지해야
            
            프레임 테이블에서 가장 중요한 작업은 사용되지 않는 프레임을 얻는 것입니다. 프레임이 비어 있으면 이 작업은 쉽습니다. 사용 가능한 프레임이 없는 경우 **프레임에서 일부 페이지를 제거하여 프레임을 사용 가능하게** 만들어야 합니다.(→ 퇴거 정책 실행)
            
            **스왑 슬롯을 할당**하지 않고는 프레임을 퇴거시킬 수 없는 상태에서 스왑 슬롯이 가득 차게 되면 커널이 패닉 상태에 빠집니다. 실제 OS는 이러한 상황을 복구하거나 방지하기 위해 다양한 정책을 적용하지만 이러한 정책은 이 프로젝트의 범위를 벗어납니다. (디스크에서도 공간이 부족할 경우)
            
            퇴거(eviction) 절차는 크게 다음 단계로 구성됩니다:
            
            1. 페이지 교체 알고리즘을 사용하여 **퇴거할 프레임을 선택**합니다. 아래에 설명된 페이지 테이블의 'accessed' 및 'dirty' 항목이 유용하게 사용될 것입니다.
            2. **프레임을 참조하는 모든 페이지 테이블에서 해당 프레임에 대한 참조를 제거**합니다.(그래서 page table이 있음) 공유를 구현하지 않는 한, 주어진 시간에 하나의 페이지만 프레임을 참조해야 합니다.
            3. 필요한 경우 **해당 페이지를 파일 시스템에 쓰거나 교체**합니다. 그러면 퇴거된 프레임은 다른 페이지를 저장하는 데 사용될 수 있습니다.
            - Accessed 및 Dirty Bits
                
                x86-64 하드웨어는 각 페이지의 **페이지 테이블 엔트리(PTE)에 있는 한 쌍의 비트**를 통해 페이지 교체 알고리즘을 구현하는 데 약간의 지원을 제공합니다. 
                
                - 페이지에 대한 읽기 또는 쓰기 시, CPU는 페이지의 PTE에서 액세스된 비트를 1로 설정
                - 쓰기 시에는 더티 비트를 1로 설정
                - CPU는 이러한 비트를 0으로 재설정하지 않지만/ OS는 재설정할 수 있습니다.
                
                동일한 프레임을 참조하는 두 개(또는 그 이상의) 페이지인 `aliases`(별칭)에 유의해야 합니다. 앨리어싱된 프레임에 액세스하면 액세스된 비트와 더티 비트는 하나의 페이지 테이블 항목(액세스에 사용된 페이지에 대한 항목)에서만 업데이트됩니다. 다른 에일리어스에 대한 액세스 및 더티 비트는 업데이트되지 않습니다.
                
                Pintos에서 모든 사용자 가상 페이지는 커널 가상 페이지에 별칭이 지정됩니다. 이러한 별칭을 어떻게든 관리해야 합니다. 예를 들어, 코드에서 두 주소 모두에 대해 액세스된 비트와 더티 비트를 확인하고 업데이트할 수 있습니다. 또는 커널이 사용자 가상 주소를 통해서만 사용자 데이터에 액세스하여 문제를 피할 수도 있습니다.
                
                다른 별칭은 공유를 구현하거나 코드에 버그가 있는 경우에만 발생해야 합니다.
                
                액세스된 비트와 더티 비트로 작업하는 함수에 대한 자세한 내용은 *[페이지 테이블 액세스 비트 및 더티 비트](https://www.notion.so/KAIST-PintOS-Assignment-fa08d9c1fc8e430f9496de59a3ae8e2c?pvs=21)* 섹션을 참조하세요.
                
        ### Swap Table 관리
            - swap 영역 관리를 위한 table
            - swap slot의 사용을 추척한다.
            
             테이블은 사용 중인 스왑 슬롯과 사용 가능한 스왑 슬롯을 추적합니다. 사용하지 않는 **스왑 슬롯**을 선택해 페이지를 **프레임에서 스왑 파티션**으로 내보낼 수 있어야 합니다. 페이지가 다시 읽혀지거나 페이지가 스왑된 프로세스가 종료될 때 스왑 슬롯을 해제할 수 있어야 합니다.
            
            `vm/build` 디렉터리에서 `pintos-mkdisk swap.dsk --swap-size=n` 명령을 사용하여 nMB 스왑 파티션이 포함된 `swap.dsk`라는 이름의 디스크를 생성합니다. 그 후 핀토스를 실행하면 `swap.dsk`가 자동으로 추가 디스크로 첨부됩니다. 또는 `--swap-size=n`을 사용하여 한 번 실행할 때 임시 n-MB 스왑 디스크를 사용하도록 pintos에 지시할 수 있습니다.
            
            스왑 슬롯은 실제로 퇴거에 필요한 경우에만 느리게(lazily) 할당해야 합니다. 실행 파일에서 데이터 페이지를 읽고 프로세스 시작 시 즉시 스왑에 쓰는 것은 *느리지 않습니다*(not lazily). **특정 페이지를 저장하기 위해 스왑 슬롯을 예약해서는 안 됩니다**.
            
            스왑 슬롯의 내용을 프레임으로 다시 읽을 때 **스왑 슬롯을 해제**하세요.
            
        ### 메모리 매핑 파일 관리
            
            파일 시스템은 `read` 및 `write` 시스템 호출을 통해 가장 일반적으로 액세스됩니다. 보조 인터페이스는 `mmap` 시스템 호출을 사용하여 파일을 가상 페이지로 "매핑"하는 것입니다. 그러면 프로그램은 파일 데이터에 직접 메모리 명령을 사용할 수 있습니다. 파일 `foo`의 길이가 `0x1000`바이트(4kB, 즉 한 페이지)라고 가정해 보겠습니다. `foo`가 주소 `0x5000`에서 시작하는 메모리에 매핑되어 있으면 `0x5000. .0x5fff` 위치에 액세스하는 모든 메모리는 `foo`의 해당 바이트에 액세스하게 됩니다.
            
            다음은 `mmap`을 사용하여 파일을 콘솔에 인쇄하는 프로그램입니다. 이 프로그램은 명령줄에 지정된 파일을 열어 가상 주소 `0x10000000`에 매핑하고, 매핑된 데이터를 콘솔에 쓴 다음(fd 1), 파일의 매핑을 해제합니다.
            
            `
            #include <stdio.h>
            #include <syscall.h>
            int main (int argc UNUSED, char *argv[])
            {
              void *data = (void *) 0x10000000;                 /* Address at which to map. */
              int fd = open (argv[1]);                          /* Open file. */
              void *map = mmap (data, filesize (fd), 0, fd, 0); /* Map file. */
              write (1, data, filesize (fd));                   /* Write file to console. */
              munmap (map);                                     /* Unmap file (optional). */
              return 0;
            }
            `
            
            제출물은 메모리 매핑된 파일에서 어떤 메모리를 사용하는지 추적할 수 있어야 합니다. 이는 매핑된 영역에서 페이지 오류를 적절히 처리하고 매핑된 파일이 프로세스 내에서 다른 세그먼트와 겹치지 않도록 하기 위해 필요합니다.

# Memory Management
    
    가상 메모리 시스템을 지원하려면 **가상 페이지**와 **물리적 프레임**을 효과적으로 관리해야 합니다. 즉, 어떤 (가상 또는 물리적) 메모리 영역이 **어떤 목적으로**, **누가**, **어떤 용도로** 사용되고 있는지 등을 추적해야 합니다. 먼저 보충 페이지 테이블을 다룬 다음 물리적 프레임을 다룰 것입니다. 이해를 돕기 위해 가상 페이지에는 '페이지'라는 용어를, 물리적 페이지에는 '프레임'이라는 용어를 사용한다는 점에 유의하세요.
    
    - **Page Structure and Operations**
        - **struct page**
            
            `include/vm/vm.h`에 정의된 `page`는 가상 메모리에 있는 페이지를 나타내는 구조입니다. 여기에는 페이지에 대해 알아야 할 모든 필수 데이터가 저장됩니다. 현재 템플릿에서 구조는 다음과 같이 보입니다:
            
            `
            struct page {
              const struct page_operations *operations;
              void *va;              /* Address in terms of user space */
              struct frame *frame;   /* Back reference for frame */
            
              union {
                struct uninit_page uninit;
                struct anon_page anon;
                struct file_page file;
            #ifdef EFILESYS
                struct page_cache page_cache;
            #endif
              };
            };
            `
            
            이 구조체에는 **페이지 연산**(아래 참조), **가상 주소**, **물리적 프레임**이 있습니다. 또한 유니온 필드도 있습니다. 유니온은 메모리 영역에 서로 다른 유형의 데이터를 저장할 수 있는 특수 데이터 유형입니다. 유니온에는 여러 멤버가 있지만 한 번에 하나의 멤버만 값을 포함할 수 있습니다. 즉, 시스템에서 페이지는 uninit_page, anon_page, file_page 또는 page_cache가 될 수 있습니다. 예를 들어 페이지가 익명 페이지인 경우(익명 페이지 참조), 페이지 구조체에는 익명 페이지에 필요한 모든 정보를 포함하는 필드 `struct anon_page anon`이 멤버 중 하나로 포함될 것입니다.`anon_page`는 익명 페이지를 지키기위한 모든 필요한 정보를 담을 것이다.
            
        - Page Operations
            
            위에서 설명한 대로 `include/vm/vm.h`에 정의된 대로, 페이지의 위치는 `VM_UNINIT`, `VM_ANON` 또는 `VM_FILE`이 될 수 있습니다. 페이지의 경우 페이지 swapping in, swapping out, 삭제(destroying) 등 여러 가지 작업을 수행할 수 있습니다. **각 페이지 유형에 따라 이러한 작업에 필요한 단계와 작업이 다릅니다**. 즉, `VM_ANON` 페이지와 `VM_FILE` 페이지에 대해 서로 다른 `destroy` 함수를 호출해야 합니다. 한 가지 방법은 각 함수에 **스위치 케이스 구문을 사용하여 각 케이스를 처리**하는 것입니다. **이를 처리하기 위해 객체 지향 프로그래밍의 "클래스 상속" 개념을 도입합니다. 실제로 C 프로그래밍 언어에는 "클래스"나 "상속"이라는 개념이 없으며, Linux와 같은 실제 운영 체제 코드에서 비슷한 방식으로 함수 포인터를 활용하여 개념을 구현합니다**.
            
            함수 포인터는 지금까지 배운 다른 포인터와 마찬가지로 메모리 내의 함수 또는 실행 코드를 가리키는 포인터입니다. **함수 포인터는 런타임 값에 따라 실행할 특정 함수를 아무런 검사 없이 호출할 수 있는 간단한 방법을 제공**하므로 유용합니다. 이 경우 코드 수준에서 단순히 `destroy(page)`를 호출하는 것으로 충분하며, 컴파일러는 올바른 함수 포인터를 호출하여 페이지 유형에 따라 적절한 `destroy` 루틴을 선택합니다.
            
            페이지 연산을 위한 `struct page_operations`는 `include/vm/vm.h`에 정의되어 있습니다. 이 구조체는 3개의 함수 포인터를 포함하는 함수 테이블이라고 생각하면 됩니다.
            
            `
            struct page_operations {
              bool (*swap_in) (struct page *, void *);
              bool (*swap_out) (struct page *);
              void (*destroy) (struct page *);
              enum vm_type type;
            };
            `
            
            이제 page_operation 구조를 어디에서 찾을 수 있는지 살펴봅시다. `include/vm/vm.h`에서 페이지 구조체 `struct page`를 살펴보면 `operations`라는 필드가 있는 것을 볼 수 있습니다. 이제 `vm/file.c`로 이동하면 함수 프로토타입 앞에 선언된 page_operation 구조체인 `file_ops`를 볼 수 있습니다. 이것은 파일 지원 페이지(file backed-page)에 대한 함수 포인터 표입니다. `.destroy` 필드에는 `file_backed_destroy` 값이 있습니다. 이것은 페이지를 삭제하는 함수이며 같은 파일에 정의되어 있습니다.
            
            함수 포인터 인터페이스로 `file_backed_destroy`가 어떻게 호출되는지 이해해 보겠습니다. `vm_dealloc_page(page)` (`vm/vm.c`에서)가 호출되고 이 페이지가 파일 백업 페이지(`VM_FILE`)라고 가정해 보겠습니다. 함수 내에서 `destroy(page)`를 호출합니다. `destroy(page)`는 다음과 같이 `include/vm/vm.h`에 매크로로 정의됩니다:
            
            `
            #define destroy(page) if ((page)->operations->destroy) (page)->operations->destroy (page)
            `
            
            이는 `destroy` 함수를 호출하면 실제로 페이지 구조에서 검색된 파괴 함수인 `(page)→operations→destroy(page)`를 호출한다는 것을 알려줍니다. 이 페이지는 `VM_FILE` 페이지이므로 `.destroy` 필드는 `file_backed_destory`를 가리킵니다. 결과적으로 파일 백업 페이지에 대한 삭제 루틴이 수행됩니다.
            
    - **Implement Supplemental Page Table**
        
        이 시점에서 핀토스에는 메모리의 가상 및 물리적 매핑을 관리하는 페이지 테이블(`pml4`)이 있습니다. 하지만 이것만으로는 충분하지 않습니다. 이전 섹션에서 설명한 대로 **페이지 오류 처리(handle page fault) 및 리소스 관리(resource management)를 처리하기 위해 각 페이지에 대한 추가 정보를 저장**하는 보조 페이지 테이블도 필요합니다. **따라서 프로젝트 3의 첫 번째 작업으로 보충 페이지 테이블에 대한 몇 가지 기본 기능을 구현하는 것이 좋습니다.**
        
        `vm/vm.c`에서 보조 페이지 테이블 관리 기능을 구현합니다.
        
        먼저 핀토스에서  보조 페이지 테이블을 **어떻게 디자인할지 결정**해야 합니다. 자신만의 보조 페이지 테이블을 디자인한 후, 디자인에 따라 아래 세 가지 기능을 구현합니다.
        
        ---
        
        `
        void supplemental_page_table_init (struct supplemental_page_table *spt);
        `
        
        보조 페이지 테이블을 초기화합니다. 보조 페이지 테이블에 **사용할 데이터 구조를 선택**할 수 있습니다. 이 함수는 새 프로세스가 시작될 때(`userprog/process.c`의 `initd`에서), 프로세스가 포크될 때(`userprog/process.c`의 `__do_fork`에서) 호출됩니다.
        
        ---
        
        `
        struct page *spt_find_page (struct supplemental_page_table *spt, void *va);
        `
        
        주어진 보조 페이지 테이블에서 va에 해당하는 `struct page`를 찾습니다. 실패하면 NULL을 반환합니다.
        
        ---
        
        `c
        bool spt_insert_page (struct supplemental_page_table *spt, struct page *page);
        `
        
        주어진 보조 페이지 테이블에 `struct page`를 삽입합니다. 이 함수는 주어진 부가 페이지 테이블에 가상 주소가 존재하지 않는지 확인해야 합니다.
        
        ---
        
        - **Frame Management**
            
            이제부터는 모든 페이지가 메모리가 생성될 당시의 **메타데이터만 보관하는 것이 아닙니다**. 따라서 물리적 메모리를 관리하기 위해서는 다른 방식이 필요합니다. `include/vm/vm.h`에는 물리적 메모리를 나타내는 `struct frame`이 존재합니다. 현재 구조체는 다음과 같습니다:
            
            `c
            /* The representation of "frame" */
            struct frame {
              void *kva;
              struct page *page;
            };
            `
            
            이 구조체에는 커널 가상 주소(kernel virtual address)인 `kva`와 페이지 구조체인 `page`라는 두 개의 필드만 있습니다. 프레임 관리 인터페이스를 구현할 때 멤버를 더 추가할 수 있습니다.
            
            `**vm/vm.c`에서 `vm_get_frame`, `vm_claim_page` 및 `vm_do_claim_page`를 구현**
            
            `c
            static struct frame *vm_get_frame (void);
            `
            
            `palloc_get_page`를 호출하여 사용자 풀에서  새로운 실제 페이지를 가져옵니다. 사용자 풀에서 페이지를 성공적으로 가져오면 프레임도 할당하고 멤버를 초기화하여 반환합니다. `vm_get_frame`을 구현한 후에는 **이 함수를 통해 모든 사용자 공간 페이지(PALLOC_USER)를 할당**해야 합니다. 페이지 할당이 실패할 경우 **지금은** 스왑 아웃을 처리할 필요가 없습니다. 당분간은 이러한 경우를 `PANIC("todo")`으로 표시하면 됩니다.
            
            `c
            bool vm_do_claim_page (struct page *page);
            `
            
            Claim, 한 페이지에 물리적 프레임을 할당합니다. 먼저 `vm_get_frame`을 호출하여 프레임을 가져옵니다(템플릿에서 이미 완료됨). 그런 다음 **MMU를 설정**해야 합니다. 즉, 가상 주소에서 페이지 테이블의 실제 주소로 매핑을 추가합니다. 반환 값은 작업이 성공했는지 여부를 나타내야 합니다.
            
            `c
            bool vm_claim_page (void *va);
            `
            
            `va`를 할당할 페이지를 claim합니다. 먼저 페이지를 가져온 다음 해당 페이지로 `vm_do_claim_page`를 호출해야 합니다.
            
# Anonymous Page
    
    이 프로젝트의 이 부분에서는 **익명 페이지라는 디스크 기반이 아닌 이미지**를 구현합니다.
    
    익명 매핑에는 백업 파일이나 장치가 없습니다. 파일 백업 페이지와 달리 이름이 지정된 파일 소스가 없기 때문에 익명 페이지입니다. 익명 페이지는 스택 및 힙과 같은 실행 파일에 사용됩니다.
    
    익명 페이지를 설명하는 구조체 `anon_page`는 `include/vm/anon.h`에 있습니다. 현재는 비어 있지만 구현할 때 필요한 정보나 익명 페이지의 상태를 저장하기 위해 멤버를 추가할 수 있습니다. 또한 페이지의 일반 정보가 포함된 `include/vm/page.h`의 `struct page`도 참조하세요. 익명 페이지의 경우 페이지 구조체에 `struct anon_page anon`이 포함되어 있습니다.
    
    - **Page Initialization with Lazy Loading**
        
        지연 로딩은 메모리가 필요한 시점까지 메모리 로딩을 지연시키는 디자인입니다. 페이지가 할당되어 해당 페이지에 해당하는 페이지 구조체가 있지만 전용 물리적 프레임이 없고 페이지의 실제 콘텐츠가 아직 로드되지 않은 상태입니다. 콘텐츠는 실제로 필요한 시점에만 로드되며, 이는 page fault로 표시됩니다.
        
        **세 가지 페이지 유형**이 있으므로 각 페이지마다 초기화 루틴이 다릅니다. 아래 섹션에서 다시 설명하겠지만, 여기서는 페이지 초기화 흐름에 대한 개략적인 보기를 제공합니다. 먼저, 커널이 새 페이지 요청을 받으면 `vm_alloc_page_with_initializer`가 호출됩니다. 이 initializer는 페이지 구조를 할당하고 페이지 유형에 따라 적절한 initializer를 설정하여 새 페이지를 초기화한 후 사용자 프로그램으로 제어권을 반환합니다. 사용자 프로그램이 실행되는 동안 어느 시점에서 프로그램이 소유하고 있다고 생각되는 페이지에 액세스하려고 하지만 해당 페이지에 아직 콘텐츠가 없는 경우 페이지 오류가 발생합니다. 오류 처리 절차 중에 `uninit_initialize`가 호출되어 앞서 설정한 initializer를 호출합니다. 이 초기화 프로그램은 익명 페이지의 경우 `anon_initializer`, 파일 지원 페이지의 경우 `file_backed_initializer`가 됩니다.
        
        페이지는 초기화->(page_fault->lazy-load->swap-in>swap-out->...)->destroy의 라이프사이클을 가질 수 있습니다. 라이프사이클의 각 전환마다 필요한 절차는 페이지 유형(또는 `VM_TYPE`)에 따라 다르며, 이전 단락은 초기화에 대한 예시였습니다. 이 프로젝트에서는 각 페이지 유형에 대해 이러한 전환 프로세스를 구현합니다.
        
    - **Lazy Loading for Executable**
        
        지연 로딩에서는 프로세스가 실행을 시작할 때 즉시 필요한 메모리 부분만 메인 메모리에 로드합니다. 이는 모든 바이너리 이미지를 한꺼번에 메모리에 로드하는 열렬한(eager) 로딩에 비해 오버헤드를 줄일 수 있습니다.
        
        지연 로딩을 지원하기 위해 `include/vm/vm.h`에 `VM_UNINIT`이라는 페이지 유형을 도입했습니다. 모든 페이지는 처음에 `VM_UNINIT` 페이지로 생성됩니다. 또한 초기화되지 않은 페이지를 위한 페이지 구조체(`include/vm/uninit.h`의 `struct uninit_page`)도 제공합니다. 초기화되지 않은 페이지를 생성, 초기화 및 소멸하는 함수는 `include/vm/uninit.c`에서 찾을 수 있으며, 당신은 이 함수를 **나중에** 완성해야 합니다.
        
        페이지 폴트 발생 시 page fault handler(`userprog/exception.c`의 `page_fault`)는 먼저 유효한(valid) page fault인지 여부를 확인하는 `vm/vm.c`의 `vm_try_handle_fault`로 제어권을 전송합니다. 여기서 유효한 오류(valid)란 유효하지 않은(invalid) 액세스에 대한 오류를 의미합니다. 가짜 오류(bonus fault)인 경우 페이지에 **일부 콘텐츠를 로드**하고 사용자 프로그램에 제어권을 반환합니다.
        
        가짜 페이지 오류(bogus page fault)에는 의 **세 가지 경우**가 있습니다: **지연 로드(lazy-loaded)**, **페이지 교체(swaped-out-page)**, **쓰기 보호된 페이지(write-protected page)**(copy-on-write(추가) 참조). 지금은 첫번째 경우인 지연 로드된 페이지에 대해서만 살펴보겠습니다. 지연 로딩에 대한 페이지 오류인 경우 커널은 이전에 `vm_alloc_page_with_initializer`에서 설정한 initializer 중 하나를 호출하여 세그먼트를 지연 로드합니다. `userprog/process.c`에서 `lazy_load_segment`를 구현해야 합니다.
        
        `vm_alloc_page_with_initializer()`를 구현합니다. 전달된 vm_유형에 따라 적절한 이니셜라이저를 가져와서 이 이니셜라이저로 `uninit_new`를 호출해야 합니다.
        
        ---
        
        `c
        bool vm_alloc_page_with_initializer (enum vm_type type, void *va,
                bool writable, vm_initializer *init, void *aux);
        `
        
        > 주어진 타입으로 초기화되지 않은 페이지를 만듭니다. uninit_page의 swap_in 핸들러는 유형에 따라 페이지를 자동으로 초기화하고 주어진 AUX로 INIT를 호출합니다. 페이지 구조가 완성되면 프로세스의 **보조 페이지 테이블에 페이지를 삽입**합니다. `vm.h`에 정의된 `VM_TYPE` 매크로를 사용하면 편리합니다.
        > 
        
        page fault handler는 호출 체인(call chain)을 따라가다가 swap_in을 호출할 때 최종적으로 `uninit_intialize`에 도달합니다. 이에 대한 완전한 구현을 제공합니다. 하지만 설계에 따라 `uninit_initializer`를 수정해야 할 수도 있습니다.
        
        ---
        
        `c
        static bool uninit_initialize (struct page *page, void *kva);
        `
        
        > 첫 번째 fault에서 페이지를 초기화합니다. 템플릿 코드는 먼저 `vm_initializer`와 `aux`를 가져와서 함수 포인터를 통해 해당 page_initializer를 호출합니다. 디자인에 따라 함수를 수정해야 할 수도 있습니다.
        > 
        
        필요에 따라 `vm/anon.c`에서 `vm_anon_init` 및 `anon_initializer`를 수정할 수 있습니다.
        
        ---
        
        `c
        void vm_anon_init (void);
        `
        
        > 익명 페이지 하위 시스템을 초기화합니다. 이 함수에서는 익명 페이지와 관련된 모든 것을 설정할 수 있습니다.
        > 
        
        ---
        
        `c
        bool anon_initializer (struct page *page,enum vm_type type, void *kva);
        `
        
        > 이 함수는 먼저 `page->operations`에서 익명 페이지에 대한 핸들러를 설정합니다. 현재 빈 구조체인 `anon_page`의 일부 정보를 업데이트해야 할 수도 있습니다. 이 함수는 익명 페이지(예: `VM_ANON`)의 이니셜라이저로 사용됩니다.
        > 
        
        `**userprog/process.c`에서 `load_segment` 및 `lazy_load_segment`를 구현합니다.** 
        
        실행 파일에서 세그먼트 로딩을 구현합니다. 이 모든 페이지들은 게으르게(lazily) 로드되어야 합니다. 즉, **커널이 페이지 오류를 그들을 위해서 intercept할 때만 로드됩니다.**
        
        프로그램 로더의 핵심인 `userprog/process.c`의 `load_segment`에 있는 루프를 수정해야 합니다. 이 루프는 매번 `vm_alloc_page_with_initializer`를 호출하여 보류(pending) 중인 페이지 객체를 생성합니다. 페이지 오류가 발생하면 파일에서 세그먼트가 실제로 로드되는 시점입니다.
        
        ---
        
        `c
        static bool load_segment (struct file *file, off_t ofs, uint8_t *upage,
                uint32_t read_bytes, uint32_t zero_bytes, bool writable);
        `
        
        > 현재 코드는 파일에서 읽을 바이트 수와 메인 루프 내에서 0으로 채울 바이트 수를 계산합니다. 그런 다음 `vm_alloc_page_with_initializer`를 호출하여 보류 중인 객체를 생성합니다. `vm_alloc_page_with_initializer`에 제공할 보조 값을 `aux` 인수로 설정해야 합니다. 바이너리 로딩에 필요한 정보를 포함하는 구조를 만들 수 있습니다.
        > 
        
        ---
        
        `c
        static bool lazy_load_segment (struct page *page, void *aux);
        `
        
        > `load_segment`에서 `vm_alloc_page_with_initializer`의 네 번째 인자로 `lazy_load_segment`가 제공되는 것을 보셨을 것입니다. 이 함수는 실행 파일의 페이지 이니셜라이저이며 페이지 오류 발생 시 호출됩니다. 이 함수는 페이지 구조체와 `aux`를 인자로 받습니다. `aux`는 `load_segment`에서 설정한 정보입니다. 이 정보를 사용하여 세그먼트를 읽을 파일을 찾아서 결국 세그먼트를 메모리로 읽어야 합니다.
        > 
        
        **새 메모리 관리 시스템에 스택 할당이 적합하도록 `userprog/process.c`의 `setup_stack`을 조정해야 합니다**. 첫 번째 스택 페이지를 느리게 할당할 필요는 없습니다. 로드 시점에 명령줄 인수를 사용하여 할당하고 초기화할 수 있으므로 결함이 발생할 때까지 기다릴 필요가 없습니다. **스택을 식별하는 방법**을 제공해야 할 수도 있습니다. `vm/vm.h`의 `vm_type`에 있는 보조 마커(예: `VM_MARKER_0`)를 사용하여 **페이지를 표시**할 수 있습니다.
        
        마지막으로, `spt_find_page`를 통해 보조 페이지 테이블을 참조하여 오류가 발생한 주소에 해당하는 페이지 구조체를 해결(resolve)하도록 `vm_try_handle_fault`함수를 수정합니다.
        
        모든 요구 사항을 구현한 후 포크를 제외한 프로젝트 2의 모든 테스트를 통과해야 합니다.
        
    - **Supplemental Page Table - Revisit(다시 살펴보기)**
        
        이제 복사 및 정리 작업을 지원하기 위해 추가 페이지 테이블 인터페이스를 다시 살펴보겠습니다. 이러한 작업은 프로세스를 생성(특히 자식 프로세스 생성)하거나 삭제할 때 필요합니다. 자세한 내용은 아래에 자세히 설명되어 있습니다. 이 시점에서 보충 페이지 테이블을 다시 살펴보는 이유는 위에서 구현한 초기화 함수 중 일부를 사용하고 싶을 수 있기 때문입니다.
        
         **`supplemental_page_table_copy` 및 `supplemental_page_table_kill`을 `vm/vm.c`에서 구현합니다.**
        
        ---
        
        `c
        bool supplemental_page_table_copy (struct supplemental_page_table *dst,
            struct supplemental_page_table *src);
        `
        
        > 보충 페이지 테이블을 src에서 dst로 복사합니다. 이 함수는 자식이 부모의 실행 컨텍스트를 상속해야 할 때 사용됩니다(예: `fork()`). src의 보충 페이지 테이블에 있는 각 페이지를 반복하여 dst의 보충 페이지 테이블에 있는 항목의 정확한 복사본을 만듭니다. 초기화되지 않은 페이지를 할당하고 즉시 청구(claim)해야 합니다.
        > 
        
        ---
        
        `c
        void supplemental_page_table_kill (struct supplemental_page_table *spt);
        `
        
        > 보조 페이지 테이블이 보유하고 있던 모든 리소스를 해제합니다. 이 함수는 프로세스가 종료될 때 호출됩니다(`userprog/process.c`의 `process_exit()`). 페이지 항목을 반복하고 테이블의 페이지에 대해 `destroy(page)`를 호출해야 합니다. 이 함수에서 실제 페이지 테이블(pml4)과 물리적 메모리(할당된 메모리)는 걱정할 필요가 없습니다. 호출자는 보조 페이지 테이블이 정리된 후 이를 정리하기 때문입니다.
        > 
    - **Page Cleanup**
        
         `vm/uninit.c`에서 `uninit_destroy`를 구현하고 `vm/anon.c`에서 `anon_destroy`를 구현합니다. 이것은 uninit page의 `destroy` 작업을 위한 핸들러입니다. uninit page가 다른 페이지 오브젝트로 변환(transmuted)되더라도 프로세스가 종료될 때 여전히 초기화되지 않은 페이지가 남아있을 수 있습니다.
        
        `c
        static void uninit_destroy (struct page *page);
        `
        
        > 페이지 구조체가 보유하던 자원을 해제합니다. 페이지의 가상 머신 유형을 확인하고 그에 따라 처리해야 할 수 있습니다.
        > 
        
        지금은 익명 페이지만 처리할 수 있습니다. 나중에 이 함수를 다시 방문하여 파일 백업 페이지를 정리할 수 있습니다.
        
        ---
        
        `c
        static void anon_destroy (struct page *page);
        `
        
        > 익명 페이지가 보유하고 있던 리소스를 해제합니다. 페이지 구조체를 명시적으로 해제할 필요는 없으며, 호출자가 해제해야 합니다.
        > 
        
        이제 **프로젝트 2의 모든 테스트가 통과**되어야 합니다.
        
# Stack Growth
    
    프로젝트 2에서 스택은 `USER_STACK`에서 시작하는 **단일 페이지**였으며, 프로그램 실행은 이 크기로 제한되었습니다. 이제 스택이 현재 크기보다 커지면 필요에 따라 **추가 페이지를 할당**합니다.
    
    **스택 액세스**로 '드러나는(appear)' **경우에만** 추가 페이지를 할당합니다. 스택 액세스와 다른 액세스를 구별하는 휴리스틱(heuristic:알고리즘 기법 중 하나)을 고안(devise)합니다.
    
    사용자 프로그램이 스택 포인터 아래의 스택에 쓰면 버그가 발생하는데, 일반적인 실제 OS는 스택의 데이터를 수정하는 '신호'를 전달하는 **어느 때고** 프로세스를 interrupt 수 있기 때문입니다. 그러나 x86-64 PUSH 명령어는 스택 포인터를 조정하기 **전**에 액세스 권한을 확인하므로 **스택 포인터 8바이트 아래에서 페이지 오류**가 발생할 수 있습니다. (액세스 권한 조정 뒤 포인터가 내려가면 스택 아래 접근)
    
    사용자 프로그램의 스택 포인터의 현재 값을 얻을 수 있어야 합니다. 시스템 콜 또는 사용자 프로그램에 의해 생성된 page fault 내에서  `syscall_handler()` 또는 `page_fault()` **각각**으로 전달된 `struct intr_frame`의 `rsp` 멤버에서 해당 값을 검색할 수 있습니다. 잘못된 메모리 액세스를 감지하기 위해 page fault에 의존할 때는 다른 케이스, **커널**에서 page fault가 발생하는 경우를 처리해야 합니다. 프로세서는 예외로 인해 **사용자 모드에서 커널 모드로 전환될 때만** 스택 포인터를 저장하므로, `**page_fault()`로 전달된 `struct intr_frame`에서 `rsp`를 읽으면 사용자 스택 포인터가 아닌 정의되지 않은 값이 반환**됩니다. 사용자 모드에서 커널 모드로 처음 전환할 때 `rsp`를 `struct thread`에 저장하는 등 다른 방법을 마련해야 합니다.
    
    **스택 성장 기능을 구현합니다.** 이를 구현하려면 먼저 `vm/vm.c`에서 `vm_try_handle_fault`를 수정하여 **스택 증가를 식별**합니다. 스택 증가를 식별한 후에는 `vm/vm.c`에서 `vm_stack_growth`를 호출하여 스택을 증가시켜야 합니다. `vm_stack_growth`를 구현합니다.
    
    ---
    
    `c
    bool vm_try_handle_fault (struct intr_frame *f, void *addr,
        bool user, bool write, bool not_present);
    `
    
    > 이 함수는 page fault 예외를 처리하는 동안 `userprog/exception.c`의 `page_fault`에서 호출됩니다. 이 함수에서는, 페이지 오류가 스택 증가의 유효한 경우인지 여부를 확인해야 합니다. 스택 증가로 오류를 처리할 수 있음을 확인했다면 오류가 발생한 주소로 `vm_stack_growth`를 호출합니다.
    > 
    
    ---
    
    `c
    void vm_stack_growth (void *addr);
    `
    
    > `addr`이 더 이상 오류 주소(faulted address)가 되지 않도록 하나 이상의 익명 페이지를 할당하여 스택 크기를 늘립니다. 할당을 처리할 때 `addr`을 PGSIZE로 round down(내림)해야 합니다.
    > 
    
    대부분의 운영체제에는 스택 크기에 대한 절대적인 제한이 있습니다. 일부 OS에서는 사용자가 `ulimit` 명령으로 제한을 조정할 수 있습니다(예: 많은 Unix 시스템에서). 많은 GNU/Linux 시스템에서 기본 제한은 8MB입니다. 이 프로젝트의 경우 **스택 크기**를 최대 1MB로 제한해야 합니다.
    
    이제 모든 스택 증가 테스트 케이스가 통과되어야 합니다.
    
# Memory Mapped Files
    
    이 섹션에서는 메모리 매핑 페이지를 구현합니다. 익명 페이지와 달리 메모리 매핑 페이지는 파일 백업 매핑(file-backed mapping)입니다. 페이지의 콘텐츠는 일부 기존 파일의 데이터를 미러링합니다. 페이지 오류가 발생하면 즉시 물리적 프레임이 할당되고 콘텐츠가 파일에서 메모리로 복사됩니다. 메모리 매핑된 페이지가 매핑 해제되거나 교체되면 콘텐츠의 모든 변경 사항이 파일에 반영됩니다.
    
    - `mmap` 및 `munmap` 시스템 호출
        
        메모리 매핑된 파일에 대한 두 가지 시스템 호출인 `mmap` 및 `munmap`을 구현합니다. VM 시스템은 mmap 영역에 페이지를 느리게 로드하고 매핑을 위한 백업 저장소로 mmaped 파일 자체를 사용해야 합니다. 이 두 시스템 호출을 구현하려면 `vm/file.c`에 정의된 `do_mmap` 및 `do_munmap`을 구현하고 사용해야 합니다.
        
        `c
        void *mmap (void *addr, size_t length, int writable, int fd, off_t offset);
        `
        
        > `fd`로 열린 파일의 `offset` 바이트에서 시작하여 `length` 바이트만큼 프로세스의 가상 주소 공간인 `addr`에 매핑합니다. 전체 파일은 `addr`에서 시작하는 연속적인 가상 페이지로 매핑됩니다. 파일 길이가 PGSIZE의 배수가 아닌 경우, 매핑된 최종 페이지의 일부 바이트가 파일 끝을 넘어 "튀어나오게" 됩니다. 페이지에 오류가 발생하면 이 바이트를 0으로 설정하고(페이지의 유효하지 않은 부분을 0으로 채우라는 뜻인 듯), 페이지가 디스크에 다시 기록되면 이 바이트를 버립니다. 성공하면 이 함수는 파일이 매핑된 가상 주소를 반환합니다. 실패하면 파일을 매핑할 수 있는 유효한 주소가 아닌 NULL을 반환해야 합니다.
        > 
        
        fd로 열린 파일의 길이가 0바이트인 경우 `mmap`호출이 실패할 수 있습니다. addr이 페이지 정렬되지 않았거나 매핑된 페이지 범위가 매핑된 페이지의 기존 세트와 겹치는 경우 (**스택인 경우,**  **실행 파일 로드 시** **매핑된 페이지**를 포함)  실패해야 합니다. Linux에서 `addr`이 NULL인 경우 커널은 매핑을 생성할 적절한 주소를 찾습니다. 단순함을 위해서, 주어진 주소에서만 매핑을 시도할 수 있습니다. 따라서 몇몇 핀토스 코드는 가상 페이지 0이 매핑되지 않았다고 가정하기 때문에 `addr`이 0이면 실패해야 합니다. `length`가 0일 때도 mmap은 실패해야 합니다. 마지막으로 콘솔 입력 및 출력을 나타내는 file descriptor는 매핑할 수 없습니다.
        
        메모리 매핑된 페이지도 익명 페이지와 마찬가지로 지연 방식으로 할당해야 합니다. `vm_alloc_page_with_initializer` 또는 `vm_alloc_page`를 사용하여 페이지 객체를 만들 수 있습니다
        
        `c
        void munmap (void *addr);
        `
        
        > 지정된 주소 범위 `addr`에 대한 매핑을 매핑 해제합니다. 이 주소는 아직 매핑 해제되지 않은 동일한 프로세스에서 이전에 mmap을 호출하여 반환한 가상 주소여야 합니다.
        > 
        
        프로세스가 `exit`되거나 다른 방법으로 종료될 때 모든 매핑은 암시적으로 매핑이 해제됩니다. 매핑이 암시적이든 명시적이든 매핑이 해제되면, **프로세스가 쓴 모든 페이지가 파일에 다시 쓰여지고, 쓰지 않은 페이지는 다시 쓰여서는 안 됩니다**. 그러면 해당 페이지는 프로세스의 가상 페이지 목록에서 제거됩니다.
        
        파일을 닫거나 제거해도 매핑이 해제되지는 않습니다. 일단 생성된 매핑은 유닉스 규칙에 따라 `munmap`이 호출되거나 프로세스가 종료될 때까지 유효합니다. 자세한 내용은 [열린 파일 제거하기](https://www.notion.so/KAIST-PintOS-Assignment-fa08d9c1fc8e430f9496de59a3ae8e2c?pvs=21)를 참조하세요. 각 매핑에 대해 파일에 대한 별도의 독립적인 참조를 얻으려면 `file_reopen`함수를 사용해야 합니다.
        
        두 개 이상의 프로세스가 동일한 파일을 매핑하는 경우 일관된 데이터를 볼 필요는 없습니다. 유닉스에서는 두 매핑이 동일한 물리적 페이지를 공유하도록 하여 이 문제를 처리하며, `mmap`시스템 호출에는 클라이언트가 페이지가 공유인지 비공개인지(즉, 복사 후 쓰기)를 지정할 수 있는 인수(argument)도 있습니다.
        
        필요에 따라 `vm/vm.c`에서 `vm_file_init` 및 `vm_file_initializer`를 수정할 수 있습니다.
        
        ---
        
        `c
        void vm_file_init(void);
        `
        
        > 파일 지원 페이지 하위 시스템을 초기화합니다. 이 함수에서는 파일 백업 페이지와 관련된 모든 것을 설정할 수 있습니다.
        > 
        
        ---
        
        `c
        void file_backed_initializer (struct page *page, enum vm_type type, void *kva);
        `
        
        > 파일 지원 페이지를 초기화합니다. 이 함수는 먼저 `page->operations`에서 파일 지원 페이지에 대한 핸들러를 설정합니다. 메모리를 백업하는 파일과 같은 페이지 구조체의 일부 정보를 업데이트할 수 있습니다.
        > 
        
        ---
        
        `c
        static void file_backed_destroy (struct page *page);
        `
        
        > 연관된 파일을 닫아 파일 백업 페이지를 삭제합니다. 내용이 더럽혀진 경우, 변경 사항을 파일에 다시 써야 합니다. 이 함수에서 페이지 구조체를 해제할 필요는 없습니다. 이 작업은 `file_backed_destroy`의 **호출자가 처리**해야 합니다.
        > 
# Swap In/Out
    
    메모리 스와핑은 물리적 메모리 사용량을 최대화하기 위한 메모리 회수(reclamation) 기술입니다. 주 메모리의 프레임이 할당되면 시스템은 사용자 프로그램의 메모리 할당 요청을 더 이상 처리할 수 없습니다. 한 가지 해결책은 현재 사용되지 않는 메모리 프레임을 디스크로 교체하는 것입니다. 이렇게 하면 일부 메모리 리소스를 확보하여 다른 애플리케이션에서 사용할 수 있습니다.
    
    스왑은 운영 체제에서 수행됩니다. **시스템이 메모리가 부족하다는 것을 감지하고 메모리 할당 요청을 받으면 디스크 스왑을 위해 퇴거할 페이지를 선택**합니다. 그런 다음 메모리 프레임의 정확한 상태가 디스크에 복사됩니다. 프로세스가 스왑아웃된 페이지에 액세스하려고 하면 OS는 정확한 콘텐츠를 다시 메모리로 가져와서 페이지를 복구합니다.
    
    퇴거를 위해 선택된 페이지는 익명 페이지 또는 파일 백업 페이지일 수 있습니다. 이 섹션에서는 각 경우를 처리합니다.
    
    **모든 스와핑 연산은 명시적으로 호출되지 않고 함수 포인터로 호출**됩니다. 이들은 각 페이지의 이니셜라이저에 대한 연산으로 등록되는 `struct page_operations file_ops`의 멤버입니다.
    
    - **Anonymous Page**
        
         **`vm/anon.c` 에 있는 `vm_anon_init` 와 `anon_initializer` 를 수정합니다 .**익명 페이지에는 익명 페이지에 대한 백업 스토리지가 없습니다. 익명 페이지의 스왑을 지원하기 위해 **스왑 디스크라는 임시 백업 스토리지를 제공**합니다. 익명 페이지에 대한 스왑을 구현할 때 스왑 디스크를 활용합니다.
        
        ---
        
        `c
        void vm_anon_init (void);
        `
        
        > 이 함수에서는 **스왑 디스크를 설정**해야 합니다. 또한 **스왑 디스크의 여유 공간과 사용 영역을 관리하기 위한 데이터 구조가 필요**합니다. 스왑 영역은 PGSIZE(4096바이트) 단위로 관리됩니다.
        > 
        
        ---
        
        `c
        bool anon_initializer (struct page *page, enum vm_type type, void *kva);
        `
        
        > 익명 페이지의 이니셜라이저입니다. 스와핑을 지원하려면 `anon_page`에 몇 가지 정보를 추가해야 합니다.
        > 
        
        이제 익명 페이지에 대한 스왑을 지원하기 위해 `vm/anon.c`에서 `anon_swap_in` 및 `anon_swap_out`을 구현합니다. 페이지를 스왑 인하려면 페이지를 **스왑 아웃해야 하므로 `anon_swap_in`을 구현하기 전에 `anon_swap_out`을 구현하는 것이 좋습니다**. 데이터 내용을 스왑 디스크로 옮긴 후 안전하게 메모리로 다시 가져와야 합니다.
        
        ---
        
        `c
        static bool anon_swap_in (struct page *page, void *kva);
        `
        
        > 디스크의 데이터 내용을 메모리로부터 읽어, 스왑 디스크에서 익명 페이지로 스왑 합니다. 데이터의 위치는 페이지가 스왑될 때 페이지 구조체에 저장되어 있어야 하는 스왑 디스크입니다. 스왑 테이블을 업데이트하는 것을 잊지 마세요(스왑 테이블 관리 참조).
        > 
        
        ---
        
        `c
        static bool anon_swap_out (struct page *page);
        `
        
        > 메모리로부터 디스크에 내용을 복사해 익명 페이지를 스왑 디스크로 스왑 합니다. 먼저, 스왑 테이블을 사용해 디스크의 빈 스왑 슬롯을 찾은 후, 데이터 페이지를 슬롯에 복사합니다. 데이터의 위치는 페이지 구조체에 저장되어야 합니다. 디스크에 더 이상 여유 슬롯이 없으면 커널을 패닉 할 수 있습니다.
        > 
        
    - **File-Mapped Page**
        
        파일 백업 페이지의 내용은 파일에서 가져오기 때문에 맵핑된 파일을 백업 저장소로 사용해야 합니다. 즉, 파일 백업 페이지를 제거하면 매핑된 파일에 다시 기록됩니다. `vm/file.c`에서 `file_backed_swap_in`, `file_backed_swap_out`을 구현합니다. 설계에 따라 `file_backed_init` 및 `file_initializer`를 수정할 수 있습니다.
        
        ---
        
        `c
        static bool file_backed_swap_in (struct page *page, void *kva);
        `
        
        > 파일로부터 내용을 읽어서 `kva`에서 페이지를 교체합니다. 파일 시스템과 동기화해야 합니다.
        > 
        
        ---
        
        `c
        static bool file_backed_swap_out (struct page *page);
        `
        
        > 파일에 내용을 다시 써서 페이지를 교환합니다. 먼저 페이지가 더티인지 확인해야 합니다. 페이지가 더럽지 않다면 파일의 내용을 수정할 필요가 없습니다. 페이지를 교체한 후에는 해당 페이지의 더티 비트를 꺼야 한다는 점을 잊지 마세요.
        > 
# Copy-on-Write (**Extra**)
    
    **핀토스에서 복사 후 쓰기 메커니즘을 구현합니다.**
    
    Copy-on-Write은 물리적 페이지의 동일한 인스턴스를 사용하여 더 빠르게 복제 작업을 수행할 수 있는 리소스 관리 기법입니다. 일부 리소스를 여러 프로세스에서 사용하는 경우 일반적으로 각 프로세스는 충돌이 발생하지 않도록 리소스의 자체 복사본을 보유해야 합니다. 그러나 리소스를 수정하지 않고 읽기만 하는 경우에는 물리적 메모리에 여러 개의 복사본을 보유할 필요가 없습니다.
    
    예를 들어 `fork`를 통해 새 프로세스가 생성되었다고 가정해 보겠습니다. 자식은 데이터를 가상 주소 공간에 복제하여 부모의 리소스를 상속해야 합니다. 일반적으로, 가상 메모리에 콘텐츠를 추가하려면 물리적 페이지를 할당하고, 프레임에 데이터를 쓰고, 페이지 테이블에 가상->물리적 매핑을 추가해야 합니다. 이러한 단계는 시간이 많이 소요될 수 있습니다.
    
    하지만 Copy-on-Write 기술을 사용하면 리소스의 **새 복사본에 대해 새 물리적 페이지를 할당하지 않습니다**. 이는 기술적으로 콘텐츠가 이미 물리적 메모리에 존재하기 때문입니다. 따라서 자식 프로세스의 **페이지 테이블에 가상->물리적 매핑만 추가**하고, 가상 주소는 이제 자식 프로세스의 메모리 공간에 있습니다. 그러면 부모와 자식은 동일한 물리적 페이지에서 동일한 데이터에 액세스하게 됩니다. 하지만 여전히 별도의 가상 주소 공간을 통해 격리되어 있으며, OS만이 동일한 프레임을 참조하고 있다는 것을 알 수 있습니다. **프로세스 중 하나가 공유 리소스의 콘텐츠를 수정하려고 시도할 때만 새 물리적 페이지에 별도의 복사본을 생성**합니다. 따라서 실제 복사 작업은 첫 번째 쓰기 작업으로 연기됩니다.
    
    즉, **OS는 복사본에 대한 쓰기 페이지에서 쓰기 시도를 감지할 수 있어야 합니다**. 이러한 요구를 충족하기 위해 OS는 "쓰기 방지(write-protect)" 메커니즘을 사용합니다. 간단한 아이디어입니다: **쓰기 액세스 시 페이지 오류를 발생시키면 됩니다**. 이는 메모리 관리 시스템의 지원으로 쉽게 구현할 수 있으며, 쓰기 방지 페이지를 아예 쓸 수 없는 페이지로 표시하기만 하면 됩니다.
    
    `fork`에 대한 copy-on-write를 구현하기만 하면 됩니다. 자식 프로세스가 부모 프로세스로부터 리소스를 상속받으면 자식이 리소스를 수정하려고 시도할 때까지 동일한 물리적 데이터를 참조할 수 있습니다. **쓰기 방지된 모든 페이지는 퇴출 후보입니다.**
    
    여기서는 복사본에 대한 기본적인 테스트 사례만 제공합니다. 가능한 모든 경우를 고려해야 합니다(작은 힌트를 드리자면, 파일로 보호된 페이지의 공유를 구현해야 합니다). 이 추가 프로젝트의 채점은 숨겨진 테스트 사례와 함께 이루어집니다.
    
# FAQ
    - 프로젝트 3을 구현하려면 프로젝트 2가 작동 중이어야 하나요?
        - 네.
    - 페이지 오류를 처리한 후 프로세스를 재개하려면 어떻게 해야 하나요?
        - `page_fault()`에서 반환하면 현재 사용자 프로세스가 재개됩니다. 그런 다음 인스트럭션 포인터가 가리키는 인스트럭션을 다시 시도합니다. 사용자 프로세스가 때때로 스택 포인터 위에서 오류가 발생하는 이유는 무엇인가요? 스택 증가 테스트에서 사용자 프로그램이 사용자 프로그램의 현재 스택 포인터보다 위에 있는 주소에서 오류가 발생하는 것을 확인할 수 있습니다.
    - 가상 메모리 시스템이 데이터 세그먼트 증가를 지원해야 하나요?
        - 아니요. 데이터 세그먼트의 크기는 링커에 의해 결정됩니다. 핀토스에는 아직 동적 할당이 없습니다(메모리 매핑 파일을 사용하여 사용자 수준에서 '가짜' 할당은 가능하지만). 데이터 세그먼트 증가를 지원한다고 해서 잘 설계된 시스템에 복잡성이 추가되는 것은 거의 없습니다.
    - 페이지 프레임을 할당할 때 `PAL_USER`를 사용해야 하는 이유는 무엇인가요?
        - `palloc_get_page(`)에 `PAL_USER`를 전달하면 **메인 커널 풀이 아닌 사용자 풀에서 메모리를 할당**합니다. 사용자 풀의 페이지가 부족하면 사용자 프로그램만 페이지를 할당하지만 커널 풀의 페이지가 부족하면 많은 커널 함수가 메모리를 가져와야 하므로 많은 오류가 발생합니다. 원하는 경우 `palloc_get_page()` 위에 다른 얼로케이터를 추가할 수 있지만, 기본 메커니즘이 되어야 합니다. 또한 `-ul` 커널 명령줄 옵션을 사용하여 사용자 풀의 크기를 제한할 수 있으므로 다양한 사용자 메모리 크기로 VM 구현을 쉽게 테스트할 수 있습니다.

Project3_Virtual Memory.md

