# PROJECT1:THREADS

- introduction
    - 들어가기
        
        이 과제에서는 여러분에게 기능이 최소한으로 포함된 스레드 시스템을 제공합니다. 여러분의 역할은 이 시스템의 기능을 확장하여 동기화 문제를 더 잘 이해하는 것입니다. 이 과제에서는 주로 threads 디렉토리에서 작업하게 되며, 부수적으로 devices 디렉토리에서도 일부 작업을 수행해야 합니다. 컴파일은 threads 디렉토리에서 수행해야 합니다. 이 프로젝트의 설명을 읽기 전에 최소한 동기화 자료를 대략적으로 살펴보는 것이 좋습니다.
        
    - 배경
        - 스레드 이해하기
            
            첫 번째 단계는 초기 스레드 시스템의 코드를 읽고 이해하는 것입니다. Pintos는 이미 스레드 생성 및 완료, 스레드 간 전환을 위한 간단한 스케줄러, 동기화 기본 요소(세마포어, 락, 조건 변수 및 최적화 배리어)를 구현하고 있습니다.
            
        - 스레드가 생성될 때는 스케줄될 새로운 컨텍스트를 생성하는 것입니다. thread_create()에게 인수로 전달되는 함수를 제공합니다. 스레드가 스케줄되고 실행되는 첫 번째 시간에 그 함수의 시작부터 시작하여 해당 컨텍스트에서 실행됩니다. 함수가 반환되면 스레드가 종료됩니다. 따라서 각 스레드는 Pintos 내에서 실행되는 mini-program처럼 작동하며, thread_create()에 전달되는 함수가 main()처럼 작동합니다.
        - 특정 시점에 정확히 하나의 스레드만 실행되며, 나머지는 비활성화됩니다. 스케줄러는 다음에 실행할 스레드를 결정합니다. (어떤 시점에서 실행할 준비가 된 스레드가 없으면 idle()에서 구현된 특수한 idle 스레드가 실행됩니다.) 동기화 기본 요소는 한 스레드가 다른 스레드가 어떤 작업을 수행하기를 기다릴 때 컨텍스트 전환이 강제될 수 있습니다.
        - 컨텍스트 전환의 작업은 threads/thread.c의 thread_launch()에 있습니다. (이를 이해할 필요는 없습니다.) 현재 실행 중인 스레드의 상태를 저장하고 전환할 스레드의 상태를 복원합니다.
        - GDB 디버거를 사용하여 컨텍스트 전환을 천천히 추적하여 어떤 일이 일어나는지 확인할 수 있습니다(GDB 참조). 먼저 schedule()에 중단점을 설정한 다음 거기서부터 단계별로 실행해보세요. 각 스레드의 주소와 상태, 각 스레드의 호출 스택에 있는 프로시저를 추적하는 것을 잊지 마세요. 한 스레드가 do_iret()에서 iret을 실행하면 다른 스레드가 실행됨을 알 수 있습니다.
        - 경고: Pintos에서 각 스레드에는 크기가 작고 고정된 실행 스택이 할당됩니다(약 4 kB). 커널은 스택 오버플로우를 감지하려고 시도하지만 완벽하게 감지할 수는 없습니다. 큰 데이터 구조를 비정적 로컬 변수로 선언하면 신비한 커널 패닉과 같은 이상한 문제를 발생시킬 수 있습니다. 예를 들어, int buf[1000];와 같이 선언하는 경우입니다. 스택 할당의 대안으로 페이지 할당기와 블록 할당기가 있습니다(메모리 할당 참조).
    - Source File
        - threads codes
            - threads 코드 (loader.S, loader.h)
                
                커널 로더입니다. PC BIOS가 메모리에 로드하는 512바이트의 코드 및 데이터로, 이후 디스크에서 커널을 찾아 메모리에 로드하고 start.S의 bootstrap()로 이동합니다. 이 코드를 살펴보거나 수정할 필요는 없습니다. start.S는 메모리 보호에 필요한 기본 설정을 수행하고 64비트 long 모드로 점프합니다. 로더와 달리 이 코드는 실제로 커널의 일부입니다.
                
            - kernel.lds.S
                
                커널을 링크하기 위해 사용되는 링커 스크립트입니다. 커널의 로드 주소를 설정하고 start.S가 커널 이미지의 처음 부분에 가까이 있도록 배열합니다. 다시 한 번 강조하지만, ~~이 코드를 살펴보거나 수정할 필요는 없지만,~~ 궁금할 경우를 위해 여기에 있습니다.
                
            - init.c, init.h
                
                커널 초기화, main()을 포함한 커널의 메인 프로그램입니다. 적어도 main()을 살펴보고 초기화되는 내용을 확인해야 합니다. 여기에 여러분만의 초기화 코드를 추가할 수도 있습니다.
                
            - thread.c, thread.h
                
                기본적인 스레드 지원입니다. 여러분의 작업의 많은 부분이 이 파일에서 이루어질 것입니다. thread.h에서는 struct thread를 정의하는데, 이는 네 개의 프로젝트 모두에서 수정할 가능성이 있습니다. 자세한 내용은 Threads를 참조하세요.
                
            - palloc.c, palloc.h
                
                4KB 페이지의 배수로 시스템 메모리를 할당하는 페이지 할당기입니다. 자세한 내용은 Page Allocator를 참조하세요.
                
            - malloc.c, malloc.h
                
                커널을 위한 malloc()과 free()의 간단한 구현입니다. 자세한 내용은 Block Allocator를 참조하세요.
                
            - interrupt.c, interrupt.h
                
                기본적인 인터럽트 처리 및 인터럽트를 켜고 끄는 함수입니다.
                
            - intr-stubs.S, intr-stubs.h
                
                저수준 인터럽트 처리를 위한 어셈블리 코드입니다. → 인터럽트는 어셈블리 코드로 동작했다고 책에서 읽었음. 
                
            - synch.c, synch.h
                
                기본 동기화 기본 요소: 세마포어, 락, 조건 변수 및 최적화 배리어입니다. 네 개의 프로젝트에서 동기화에 이를 사용해야 합니다. 자세한 내용은 Synchronization을 참조하세요.
                
            - mmu.c, mmu.h
                
                x86-64 페이지 테이블 작업을 위한 함수입니다. 이 파일은 lab1 이후에 자세히 살펴볼 것입니다.
                
            - io.h
                
                I/O 포트 접근을 위한 함수입니다. 주로 여러분이 건드릴 필요가 없는 devices 디렉토리의 소스 코드에서 사용됩니다.
                
            - vaddr.h, pte.h
                
                가상 주소 및 페이지 테이블 엔트리 작업을 위한 함수 및 매크로입니다. 이것들은 프로젝트 3에서 더 중요해질 것입니다. 현재는 무시해도 됩니다.
                
            - flags.h
                
                x86-64 플래그 레지스터의 몇 가지 비트를 정의하는 매크로입니다. 아마도 관심이 없을 것입니다.
                
        - device codes
            - timer.c, timer.h
            
            기본적으로 초당 100번의 틱을 하는 시스템 타이머입니다. 이 프로젝트에서 이 코드를 수정할 것입니다.
            
            - vga.c, vga.h
            
            VGA 디스플레이 드라이버입니다. 화면에 텍스트를 쓰는 역할을 합니다. 여러분이 이 코드를 살펴볼 필요는 없을 것입니다. printf() 호출은 자동으로 VGA 디스플레이 드라이버로 이루어지므로 여러분 스스로 이 코드를 호출할 필요는 거의 없습니다.
            
            - serial.c, serial.h
            
            시리얼 포트 드라이버입니다. 다시 말하지만, printf() 호출은 이 코드를 대신 수행하기 때문에 여러분이 직접 이 코드를 사용할 필요는 없습니다. 시리얼 입력은 입력 레이어로 전달되어 처리됩니다(아래 참조).
            
            - block.c, block.h
            
            블록 장치를 위한 추상화 레이어로, 고정 크기 블록의 배열로 구성된 임의 접근 디스크와 유사한 장치입니다. Pintos는 기본적으로 두 가지 유형의 블록 장치를 지원합니다: IDE 디스크와 파티션. 유형에 관계없이 블록 장치는 프로젝트 2에서 실제로 사용되지 않을 것입니다.
            
            - ide.c, ide.h
            
            최대 4개의 IDE 디스크에서 섹터를 읽고 쓰는 기능을 지원합니다.
            
            - partition.c, partition.h
            
            디스크의 파티션 구조를 이해하여 하나의 디스크를 여러 영역(파티션)으로 나누어 독립적으로 사용할 수 있게 합니다.
            
            - kbd.c, kbd.h
            
            키보드 드라이버입니다. 키 입력을 처리하여 입력 레이어로 전달합니다(아래 참조).
            
            - input.c, input.h
            
            입력 레이어입니다. 키보드 또는 시리얼 드라이버에서 전달된 입력 문자를 큐에 저장합니다.
            
            - intq.c, intq.h
            
            커널 스레드와 인터럽트 핸들러가 액세스하려는 원형 큐를 관리하는 인터럽트 큐입니다. 키보드와 시리얼 드라이버에서 사용됩니다.
            
            - rtc.c, rtc.h
            
            실시간 시계 드라이버로, 커널이 현재 날짜와 시간을 결정할 수 있게 합니다. 기본적으로 이는 thread/init.c에서 난수 발생기의 초기 시드를 선택하는 데에만 사용됩니다.
            
            - speaker.c, speaker.h
            
            PC 스피커에서 소리를 내는 드라이버입니다.
            
            - pit.c, pit.h
            
            8254 Programmable Interrupt Timer를 구성하는 코드입니다. 각 장치가 PIT의 출력 채널 중 하나를 사용하기 때문에 devices/timer.c와 devices/speaker.c에서 이 코드가 사용됩니다.
            
        - lib codes
            
            마지막으로, lib와 lib/kernel에는 유용한 라이브러리 루틴이 포함되어 있습니다. (lib/user는 프로젝트 2부터 사용될 것이며, 그러나 커널의 일부는 아닙니다.) 여기에 몇 가지 자세한 내용이 있습니다:
            
            ctype.h, inttypes.h, limits.h, stdarg.h, stdbool.h, stddef.h, stdint.h, stdio.c, stdio.h, stdlib.c, stdlib.h, string.c, string.h
            
            표준 C 라이브러리의 일부입니다.
            
            debug.c, debug.h
            
            디버깅을 돕는 함수와 매크로입니다. 자세한 정보는 디버깅 도구를 참조하세요.
            
            random.c, random.h
            
            의사 난수 생성기입니다. 실제로 랜덤 값의 시퀀스는 Pintos 실행 간에 달라지지 않을 것입니다.
            
            round.h
            
            반올림을 위한 매크로입니다.
            
            syscall-nr.h
            
            시스템 호출 번호입니다. 프로젝트 2까지는 사용되지 않습니다.
            
            kernel/list.c, kernel/list.h
            
            이중 연결 목록 구현입니다. Pintos 코드 전반에 걸쳐 사용되며, 프로젝트 1에서도 몇 군데에서 사용할 수 있습니다. 시작하기 전에 이 코드를 대략적으로 훑어보는 것이 좋습니다(특히 헤더 파일의 주석을 참고하세요).
            
            kernel/bitmap.c, kernel/bitmap.h
            
            비트맵 구현입니다. 필요하다면 코드에서 사용할 수 있지만, 프로젝트 1에서는 아마 필요하지 않을 것입니다.
            
            kernel/hash.c, kernel/hash.h
            
            해시 테이블 구현입니다. 프로젝트 3에서 유용할 것입니다.
            
            kernel/console.c, kernel/console.h, kernel/stdio.h
            
            printf() 및 기타 몇 가지 함수를 구현합니다.
            
    - ****Synchronization****
        
        올바른 동기화는 이러한 문제의 해결에 중요한 부분입니다. 동기화 문제는 모두 인터럽트를 끄는 방식으로 쉽게 해결될 수 있습니다. 인터럽트가 꺼져 있으면 동시성이 없으므로 경쟁 조건이 발생하지 않습니다. 따라서 이 방법으로 모든 동기화 문제를 해결하는 것이 유혹적일 수 있지만, 그렇게 하지 마십시오. 대신 세마포어, 락 및 조건 변수를 사용하여 대부분의 동기화 문제를 해결하세요. 어떤 상황에서 동기화 기본 요소를 사용해야 하는지에 대한 정보는 동기화 섹션(동기화 참조) 또는 threads/synch.c의 주석을 참고하세요.
        
        Pintos 프로젝트에서 인터럽트를 비활성화하여 해결하는 가장 적합한 문제 유형은 커널 스레드와 인터럽트 핸들러 간에 공유된 데이터를 조정하는 것입니다. 인터럽트 핸들러는 sleep할 수 없기 때문에 락을 얻을 수 없습니다. 따라서 커널 스레드 내에서 인터럽트를 꺼 커널 스레드와 인터럽트 핸들러 간에 공유된 데이터를 보호해야 합니다.
        
        이 프로젝트에서는 인터럽트 핸들러에서 약간의 스레드 상태에 액세스하는 것만 필요합니다. 알람 시계에서는 타이머 인터럽트가 슬리핑 중인 스레드를 깨워야 합니다. 고급 스케줄러에서는 타이머 인터럽트가 몇 가지 전역 및 스레드별 변수에 액세스해야 할 수 있습니다. 이러한 변수에 커널 스레드에서 액세스할 때 타이머 인터럽트의 간섭을 방지하기 위해 인터럽트를 비활성화해야 합니다.
        
        인터럽트를 끄는 경우, 최소한의 코드에서만 그렇게 해야 합니다. 그렇지 않으면 타이머 틱이나 입력 이벤트와 같은 중요한 것들을 잃을 수 있습니다. 인터럽트를 끄는 것은 인터럽트 처리 지연 시간을 증가시키므로 지나치게 많이 끄면 기계가 느린 것처럼 느껴질 수 있습니다.
        
        synch.c의 동기화 기본 요소 자체는 인터럽트를 비활성화하여 구현됩니다. 여기서 인터럽트가 비활성화된 상태에서 실행되는 코드 양을 늘려야 할 수도 있지만 최소한으로 유지하려고 노력해야 합니다.
        
        디버깅을 위해 인터럽트를 비활성화하는 것은 유용할 수 있습니다. 코드의 특정 부분이 인터럽트를 받지 않도록 보장하려면 이 기능을 사용할 수 있습니다. 프로젝트를 제출하기 전에 디버깅 코드를 제거해야 합니다. (주석 처리하는 것만으로는 코드가 읽기 어려워질 수 있으니 주의하세요.)
        
        제출물에는 바쁜 대기(busy waiting)가 있으면 안 됩니다. thread_yield()를 호출하는 밀집한 루프는 바쁜 대기의 한 형태입니다.
        
    - ****Development Suggestions****
        
        과거에 많은 그룹이 과제를 조각내어 각 그룹원이 마감 직전까지 자신의 부분에만 작업한 후, 그룹이 다시 모여 코드를 합치고 제출했습니다. 이는 좋지 않은 아이디어입니다. 우리는 이러한 접근 방식을 추천하지 않습니다. 이 방법을 선택한 그룹들은 종종 두 가지 변경 사항이 충돌하여 많은 마지막 순간 디버깅이 필요한 경우가 많았습니다. 이를 선택한 일부 그룹은 심지어 컴파일이나 부팅조차 되지 않는 코드를 제출하기도 했습니다.
        
        대신, 우리는 git과 같은 소스 코드 관리 시스템을 사용하여 팀의 변경 사항을 조기에 자주 통합하는 것을 권장합니다. 이 방식은 모든 사람이 완성된 코드를 보는 대신 코드가 작성되는 과정에서 모두가 다른 사람의 코드를 볼 수 있기 때문에 놀라움을 줄일 수 있습니다. 이러한 시스템은 변경 사항을 검토하고, 변경 사항이 버그를 도입할 때 작동 중인 코드로 되돌릴 수 있는 기능을 제공합니다.
        
        이번 프로젝트 및 이후 프로젝트를 진행하면서 이해할 수 없는 버그들을 만날 것으로 예상해야 합니다. 이때는 디버깅 도구에 대한 부록을 다시 읽어보세요. 유용한 디버깅 팁이 담겨 있어 문제를 해결하는 데 도움이 될 것입니다 (디버깅 도구 참조). 또한 백트레이스에 대한 섹션(백트레이스 참조)을 읽어보세요. 이는 커널 패닉이나 어설션 실패를 최대한 활용할 수 있도록 도와줄 것입니다.
        
    
- Alarm Clock
    - 알람 시계
        
        devices/timer.c 파일에 정의된 timer_sleep() 함수를 다시 구현합니다.
        
        동작하는 구현이 제공되었지만, 이는 busy waiting, 즉, 현재 시간을 확인하고 thread_yield()를 호출하여 충분한 시간이 경과할 때까지 루프에서 계속 도는 방식(무한루프?)입니다. busy waiting을 피하기 위해 다시 구현하세요.
        
        void timer_sleep (int64_t ticks);
        호출한 스레드의 실행을 중지하고 최소 x 타이머 틱이 경과할 때까지 대기합니다. 시스템이 아무리 바쁘지 않더라도, 스레드가 정확히 x 타이머 틱 후에 깨어나야 하는 것은 아닙니다. 올바른 시간만큼 기다린 후에는 ready 큐에 넣어주세요.
        
        timer_sleep()은 실시간으로 작동하는 스레드에 유용합니다. 예를 들어 1초에 한 번씩 커서를 깜박이는 작업에 사용됩니다. timer_sleep()의 인수는 타이머 틱으로 표현되며, 밀리초나 다른 단위가 아닙니다. 초당 TIMER_FREQ 타이머 틱이 있으며, TIMER_FREQ는 devices/timer.h에 정의된 매크로입니다. 기본 값은 100입니다. 많은 테스트가 실패할 수 있는 변경 사항이 발생할 수 있기 때문에 이 값을 변경하는 것은 권장하지 않습니다.
        
        특정 밀리초, 마이크로초 또는 나노초에 대해 sleep하는 timer_msleep(), timer_usleep(), timer_nsleep() 함수가 별도로 존재하지만, 필요한 경우 이 함수들은 자동으로 timer_sleep()를 호출합니다. 여기에 수정할 필요가 없습니다. 알람 시계 구현은 이후 프로젝트에서 필요하지 않지만, 프로젝트 4에 유용할 수 있습니다.
        
    - FAQ
        
        무엇을 알고 싶은지 이해했습니다. 번역을 도와드리겠습니다:
        
        ### 소스 파일 추가 및 Makefile 업데이트:
        
        새 `.c` 파일을 추가할 때는 각 하위 디렉토리의 관련 Makefile을 업데이트해야 합니다. `targets.mk` 파일을 편집하여 `dir_SRC` 변수에 새 파일을 추가합니다. 여기서 `dir`은 `targets.mk` 파일이 위치한 디렉토리를 나타냅니다. 변경을 완료한 후에는 `make` 명령을 실행하세요. 새 파일이 컴파일되지 않는 경우 `make clean`을 실행한 다음 다시 컴파일하세요.
        
        ### "이전에 선언된 프로토타입이 없음" 경고:
        
        이 경고는 함수가 선언되기 전에 사용되었음을 나타냅니다. 이를 해결하려면 해당 함수의 프로토타입을 다른 파일에서 사용되기 전에 포함된 헤더 파일에 제공하십시오. 또는 함수가 파일 외부에서 사용되지 않는 경우 `static`으로 표시하세요.
        
        ### 타이머 인터럽트 간격 및 타임 슬라이스:
        
        타이머 인터럽트는 초당 `TIMER_FREQ` 번 발생하며, 이 값은 `devices/timer.h`에서 조정 가능합니다. 타임 슬라이스는 각 스레드에 할당되는 실행 시간 단위입니다. `threads/thread.c`에서 `TIME_SLICE` 매크로로 정의되며, 기본값은 4틱입니다. 이 값을 변경하는 것은 권장되지 않습니다. 변경 시 많은 테스트가 실패할 가능성이 있습니다.
        
        ### 테스트 실행 방법:
        
        테스트 실행 방법은 "Testing"을 참조하세요.
        
        ### pass()에서 테스트 실패 이유:
        
        아래와 같은 모습의 백트레이스(backtrace)가 나타나면 아마도 다음과 같은 혼란스러운 출력을 보고 계실 것입니다:
        
        0x8004208810: debug_panic (lib/kernel/debug.c:32)
        0x800420a99f: pass (tests/threads/tests.c:93)
        0x800420bdd3: test_mlfqs_load_1 (...threads/mlfqs-load-1.c:33)
        0x800420a8cf: run_test (tests/threads/tests.c:51)
        0x8004200452: run_task (threads/init.c:283)
        0x8004200536: run_actions (threads/init.c:333)
        0x80042000bb: main (threads/init.c:137)
        
        이는 단순히 백트레이스 프로그램에서 나오는 혼란스러운 출력입니다. 실제로 pass()가 debug_panic()을 호출한 것은 아닙니다. 사실, fail() 함수가 debug_panic()을 호출했습니다 (PANIC() 매크로를 통해). GCC는 debug_panic()이 NO_RETURN으로 선언되어 반환되지 않는다는 것을 알기 때문에, fail() 함수 내부에 debug_panic()이 반환될 때 제어를 가져가는 코드를 포함하지 않습니다. 이는 스택 상의 반환 주소가 메모리 상에서 fail() 함수 뒤에 따라오는 함수의 시작 부분에 위치한 것처럼 보이는데, 이 경우에는 pass() 함수입니다. 자세한 내용은 백트레이스(Backtraces)를 참조하세요.
        
        ### 새로운 스레드에서 인터럽트가 다시 활성화되는 방법:
        
        schedule()로의 모든 경로는 인터럽트를 비활성화합니다. 다음으로 스케줄되는 새로운 스레드에 의해 인터럽트는 다시 활성화됩니다. 가능성을 고려해보면, 새로운 스레드는 switch_thread()에서 실행 중일 수 있습니다 (하지만 아래 내용을 참조하세요). 이 함수는 schedule()에서 호출되며, schedule()은 몇 가지 가능한 함수 중 하나에 의해 호출됩니다:
        
        thread_exit()인 경우, 해당 스레드로 다시 돌아오지 않으므로 관심 대상이 아닙니다.
        thread_yield()인 경우, schedule()에서 반환될 때 즉시 인터럽트 수준이 복원됩니다.
        thread_block()인 경우, 여러 곳에서 호출됩니다:
        
        - sema_down()인 경우, schedule()에서 반환될 때 즉시 인터럽트 수준이 복원됩니다.
        - idle()인 경우, 명시적으로 어셈블리어 STI 명령으로 인터럽트를 활성화합니다.
        - devices/intq.c의 wait()는 호출자가 인터럽트를 다시 활성화해야 합니다.
        
        새로운 스레드가 처음 실행될 때 특별한 경우가 있습니다. 이러한 스레드는 kernel_thread()의 맨 아래에 있는 intr_enable()을 첫 번째로 호출합니다. 이 함수는 모든 커널 스레드에서 첫 번째 이외의 스레드에서 호출되며, 호출 스택의 맨 아래에 위치합니다.
        
        ### 타이머 값이 오버플로우하는 것을 고려해야 할 필요성:
        
        타이머 값의 오버플로우 가능성을 걱정할 필요는 없습니다. 타이머 값은 100틱당 64비트 부호 있는 숫자로 표현되며, 약 2,924,712,087년 동안 유효합니다.
        
        ### 우선 순위 스케줄링이 기아를 유발할 수 있는 이유:
        
        네, 엄격한 우선 순위 스케줄링은 더 높은 우선 순위의 스레드가 실행 가능한 경우 다른 스레드가 실행되지 않기 때문에 기아(starvation) 상태를 유발할 수 있습니다. 고급 스케줄러는 스레드 우선 순위를 동적으로 변경하는 메커니즘을 도입합니다. 엄격한 우선 순위 스케줄링은 실시간 시스템에서 유용하며, 프로그래머에게 어떤 작업이 처리 시간을 받을지에 대해 더 많은 제어를 제공합니다. 높은 우선 순위는 일반적으로 시간적으로 중요한 작업에 예약됩니다. 이것은 "공정(fair)"하지 않을 수 있지만, 일반 목적의 운영 체제에 적용되지 않는 다른 관련된 문제들을 다루기 위해 사용됩니다.
        
        ### lock 해제 후 어떤 스레드가 실행되어야 하는가:
        
        lock이 해제되면 해당 lock을 기다리고 있는 가장 높은 우선 순위의 스레드가 unblock되고 준비된 스레드 목록에 추가되어야 합니다. 그런 다음 스케줄러는 준비된 스레드 중에서 가장 높은 우선 순위의 스레드를 실행해야 합니다.
        
        ### 가장 높은 우선 순위 스레드가 양보하면 계속 실행되는가:
        
        하나의 가장 높은 우선 순위 스레드가 있는 경우, 그 스레드는 다른 스레드가 블록되거나 종료될 때까지 실행됩니다. 여러 스레드가 동일한 최고 우선 순위를 가지는 경우, `thread_yield()`를 호출하더라도 해당 스레드는 계속 실행됩니다.////
        
        ### 기부 스레드의 우선 순위 변화:
        
        우선 순위 기부는 기부받은 스레드의 우선 순위를 변경하며, 기부한 스레드의 우선 순위는 변경되지 않습니다. 기부된 우선 순위는 더해지지 않습니다. 즉, 스레드 A(우선 순위 5)가 스레드 B(우선 순위 3)에 기부하는 경우, B의 새로운 우선 순위는 5가 됩니다.
        
        - 우선순위가 높을수록 더 빨리 처리되는거?
            - 네, 일반적으로 우선 순위 값이 더 높을수록 해당 스레드가 더 높은 우선순위로 처리됩니다. 운영 체제는 일반적으로 높은 우선 순위를 가진 스레드에게 CPU 시간을 더 많이 할당하여 더 우선적으로 실행되도록 합니다. 따라서 더 높은 우선 순위의 스레드는 낮은 우선 순위의 스레드보다 더 빠르게 처리될 가능성이 있습니다.
        
        ### 스레드가 준비 큐에 있는 동안 우선 순위가 변경될 수 있는가:
        
        네. 스레드가 어떤 이유로든 블록된 상태일 때, 해당 스레드가 잠금(Lock) L을 획득한 경우, 더 높은 우선 순위의 스레드가 해당 잠금을 획득하려고 시도하면 우선 순위 기부(priority donation)로 인해 해당 스레드의 우선 순위가 증가할 수 있습니다. 이러한 경우는 priority-donate-sema 테스트에서 확인됩니다.
        
        - 스레드가 준비상태일때, 준비 큐에서 대기하고 있는건가요?
            - 네, 일반적으로 스레드가 블록된 상태일 때(예: 잠금을 얻지 못하거나 입출력 작업을 기다리는 경우), 해당 스레드는 준비 큐에서 대기하게 됩니다. 블록된 상태에 있는 스레드는 일시적으로 실행을 중단하고, 필요한 조건이 충족될 때까지 대기 상태로 들어가게 됩니다. 이때 다른 스레드가 실행되며, 준비 큐에 있는 스레드 중 어떤 것이 CPU를 할당받을지 결정됩니다. 만약 해당 스레드가 조건이 충족되어 다시 실행 가능한 상태로 변경된다면, 운영 체제는 이를 준비 큐에 삽입하여 실행 대기 상태로 유지합니다.///////
        
        ### 스레드가 준비 목록에 추가되면 프로세서를 선점할 수 있나요?
        
        네. 준비 목록에 추가된 스레드가 실행 중인 스레드보다 높은 우선 순위를 가지면 올바른 동작은 즉시 프로세서를 양보하는 것입니다. 다음 타이머 인터럽트를 기다리는 것은 허용되지 않습니다. 가장 높은 우선 순위 스레드는 실행 가능해지자마자 즉시 실행되어 현재 실행 중인 스레드를 선점해야 합니다.
        
        ### thread_set_priority()가 기부를 받는 스레드에 어떤 영향을 미치나요?
        
        이 함수는 스레드의 기본 우선 순위를 설정합니다. 스레드의 유효한 우선 순위는 새로 설정된 우선 순위 또는 받은 최고 우선 순위 중 높은 값으로 결정됩니다. 기부가 해제되면 스레드의 우선 순위는 이 함수 호출을 통해 설정된 값이 됩니다. 이 동작은 priority-donate-lower 테스트에서 확인됩니다.
        
        출력에서 테스트 이름이 두 번씩 나오면 테스트가 실패합니다.
        만약 다음과 같이 테스트 이름이 두 번씩 나오는 출력을 보신다면:
        
        (alarm-priority) begin
        (alarm-priority) (alarm-priority) Thread priority 30 woke up.
        Thread priority 29 woke up.
        (alarm-priority) Thread priority 28 woke up.
        
        두 스레드의 출력이 교차되어 나타나고 있습니다. 즉, 하나의 스레드가 (alarm-priority) Thread priority 29 woke up.\n를 출력하고 다른 스레드가 (alarm-priority) Thread priority 30 woke up.\n를 출력하고 있지만, 첫 번째 스레드는 출력 중간에 두 번째 스레드에 의해 선점되고 있습니다. 이 문제는 우선 순위 스케줄러에서 버그가 있음을 나타냅니다. 우선 순위가 29인 스레드가 우선 순위가 30인 스레드가 작업을 처리할 때 실행되어서는 안 됩니다. 일반적으로 Pintos 커널의 printf() 함수는 printf 호출 중에 콘솔 잠금을 획득하고 이후에 잠금을 해제하는 방식으로 교차 출력을 방지합니다. 그러나 (alarm-priority)와 그 뒤에 오는 메시지를 출력할 때 두 번의 printf 호출로 인해 콘솔 잠금이 두 번 획득 및 해제됩니다.
        
        ### 우선 순위 기부가 고급 스케줄러와 어떻게 상호 작용하는가?
        
        상호 작용할 필요가 없습니다. 우선 순위 기부와 고급 스케줄러를 동시에 테스트하지 않을 것입니다.
        
        ### 64개 대신에 하나의 큐를 사용할 수 있나요?
        
        네. 일반적으로 동일한 동작을 보장하는 한, 설명과 다른 구현을 사용할 수 있습니다.
        
        ### 일부 스케줄러 테스트가 실패하고 원인을 이해할 수 없습니다. 도와주세요!
        
        고급 스케줄러 테스트 중 일부가 의도치 않게 실패한다면 다음을 시도해보세요:
        
        실패하는 테스트의 소스 파일을 읽어서 목적과 예상 결과를 이해하는지 확인하세요. 각 테스트는 목적과 예상 결과를 설명하는 주석을 가지고 있습니다.
        고정 소수점 산술 루틴 및 스케줄러 루틴에서 사용하는 방법을 다시 확인하세요.
        타이머 인터럽트에서 수행되는 작업을 고려해보세요. 타이머 인터럽트 핸들러가 너무 오랜 시간을 소요한다면, 인터럽트로 선점된 스레드에게 대부분의 타이머 틱이 소비될 것입니다. 따라서 해당 스레드는 다음 타이머 인터럽트가 도착하기 전에 많은 일을 수행하지 못하게 됩니다. 이로 인해 해당 스레드의 최근 CPU 시간이 증가하여 우선 순위가 낮아질 수 있습니다. 이는 스케줄링 결정을 변경할 수 있습니다. 또한 로드 평균을 높일 수 있습니다.
        
- Priority Schedule
    
    다음과 같이 일부 테스트 이름이 두 배로 표시되는 출력이 있다고 가정해 보겠습니다:
    
    ```jsx
    (alarm-priority) begin
    (alarm-priority) (alarm-priority) Thread priority 30 woke up.
    Thread priority 29 woke up.
    (alarm-priority) Thread priority 28 woke up.
    ```
    
    두 스레드의 출력이 인터리빙되고 있는 것입니다. 즉, 한 스레드는 (알람 우선순위) 스레드 우선순위 29가 깨어났습니다.\n을 출력하고 있고 다른 스레드는 (알람 우선순위) 스레드 우선순위 30이 깨어났습니다.\n을 출력 중인데 첫 번째 스레드가 출력 도중에 두 번째 스레드에 의해 선점당하고 있는 것입니다. 이 문제는 우선순위 스케줄러에 버그가 있음을 나타냅니다. 결국, 우선 순위가 29인 스레드는 우선 순위가 30인 스레드가 할 일이 있는 동안 실행할 수 없어야 합니다. 일반적으로 핀토스 커널의 printf() 함수 구현은 printf 호출 기간 동안 콘솔 잠금을 획득했다가 나중에 해제하여 이러한 인터리브 출력을 방지하려고 시도합니다. 그러나 테스트 이름(예: (알람 우선순위))과 그 뒤에 나오는 메시지의 출력은 printf를 두 번 호출하여 출력되므로 콘솔 잠금이 두 번 획득되고 해제됩니다.
    
- Advanced Schedule
    - 고급 스케줄러
        
        4.4BSD 스케줄러와 유사한 다단계 피드백 대기열 스케줄러를 구현하여 시스템에서 실행 중인 작업의 평균 응답 시간을 단축하세요.
        
        우선순위 스케줄러와 마찬가지로 고급 스케줄러는 우선순위에 따라 실행할 스레드를 선택합니다. 그러나 고급 스케줄러는 우선순위 기부를 수행하지 않습니다. 따라서 고급 스케줄러에서 작업을 시작하기 전에 우선순위 기부를 제외하고 우선순위 스케줄러를 작동시키는 것이 좋습니다.
        
        → 고급 스케쥴러 = (우선 순위 스케쥴러 - 우선순위 기부)부터 시작…!
        
        핀토스 시작 시 스케줄링 알고리즘 정책을 선택할 수 있도록 코드를 작성해야 합니다. 기본적으로 우선순위 스케줄러가 활성화되어 있어야 하지만 -mlfqs 커널 옵션으로 4.4BSD 스케줄러를 선택할 수 있어야 합니다. 이 옵션을 전달하면 main() 초기에 발생하는 parse_options()에 의해 옵션이 구문 분석될 때 threads/thread.h에 선언된 thread_mlfqs가 true로 설정됩니다.
        
        → 알고리즘 설정 옵션 선택(-mlfqs 옵션)
        
        → 옵션 전달시에, main()의 parse_options()에 의해 파싱되어, thread-mlfqs가 true로 설정..!
        
        4.4BSD 스케줄러가 활성화되면, 스레드는 더 이상 자신의 우선순위를 직접 제어하지 않습니다. thread_create()에 대한 우선순위 인자는 무시(supercial_priority 무시)되어야 하며, thread_set_priority()에 대한 호출도 무시되어야 하며, thread_get_priority()는 (4.4BSD 고급)스케줄러가 설정한 스레드의 현재 우선순위(base_priority로, donor에서 말고)를 반환해야 합니다. 고급 스케줄러는 이후 프로젝트에서 사용되지 않습니다.
        
        → (superficial_priority 무시)thread_get_priority()는 (4.4BSD 고급)스케줄러가 설정한 스레드의 현재 우선순위를 반환
        
        → thread.c 에서 priority base껄로 가져옴
        
    - 4.4BSD 스케쥴러
        
        범용 스케줄러의 목표는 스레드의 다양한 스케줄링 요구 사항의 균형을 맞추는 것입니다. 많은 입출력을 수행하는 스레드는 입력 및 출력 장치를 바쁘게 유지하기 위해 빠른 응답 시간이 필요하지만 CPU 시간은 거의 필요하지 않습니다. 반면에 compute-bound 스레드는 작업을 완료하기 위해 많은 CPU 시간이 필요하지만 빠른 응답 시간은 필요하지 않습니다. 다른 스레드는 이 둘의 중간 지점에 위치하며, 입출력 주기와 계산 주기가 구분되어 있으므로 시간에 따라 요구 사항이 달라집니다. 잘 설계된 스케줄러는 이러한 모든 요구 사항을 가진 스레드를 동시에 수용할 수 있는 경우가 많습니다.
        
        → 세가지 유형을 대비하기 위해서 mlfqs 스케쥴러 사용
        
        프로젝트 1의 경우 이 부록에 설명된 스케줄러를 구현해야 합니다. 우리의 스케줄러는 multilevel feedback queue 스케줄러의 한 예인 [McKusick]에 설명된 것과 유사합니다. 이 유형의 스케줄러는 ready-to-run 스레드의 여러 대기열을 유지하며, 각 대기열은 서로 다른 우선순위를 가진 스레드를 보유합니다. 스케줄러는 언제든지 우선순위가 가장 높은 비어 있지 않은 대기열에서 스레드를 선택합니다. (각 우선순위들을 가지고 있는 스레드들을 큐에 담아놓는듯…)우선순위가 가장 높은 대기열에 여러 개의 스레드가 포함되어 있으면 스레드가 "라운드 로빈" 순서로 실행됩니다.(같은 우선순위에서 RR수행)
        
        스케줄러의 multiple facet 특정 타이머 틱 횟수 후에 데이터를 업데이트해야 합니다. 모든 경우에 이러한 업데이트는 일반 커널 스레드가 실행될 기회를 갖기 전에 이루어져야 커널 스레드가 새로 증가한 timer_ticks() 값 대신 이전 스케줄러 데이터 값을 볼 가능성이 없습니다.
        
        → 스레드가 실행되기 전에, 데이터 업데이트를 수행하기 때문에, 그래서, 
        
        4.4BSD 스케줄러에는 우선순위 기부가 포함되어 있지 않습니다.
        
    - Niceness
        
        스레드 우선순위는 스케줄러가 아래 공식을 사용하여 동적으로 결정합니다. 그러나 각 스레드에는 다른 스레드에 대해 스레드가 얼마나 "좋은지"를 결정하는 정수 nice 값도 있습니다. 0의 nice값은 스레드 우선순위에 영향을 주지 않습니다. 최대 20까지 양수인 nice은 스레드의 우선순위를 낮추고 다른 방법으로는 받을 수 있는 CPU 시간을 일부 포기하게 합니다. 반면에 최소 -20의 음의 nice 값은 다른 스레드에서 CPU 시간을 빼앗는 경향이 있습니다.(take away)
        
        → 양의 nice 값:  자신의 우선순위 낮추고, 양보
        
        → 음의 nice 값: 다른 스레드의 CPU시간 뻇어옴. 뺏음
        
        초기 스레드는 0이라는 nice 값으로 시작합니다. 다른 스레드는 부모 스레드에서 상속받은 nice 값으로 시작합니다. 테스트 프로그램에서 사용하기 위해 아래에 설명된 함수를 구현해야 합니다. 이 함수들에 대한 스켈레톤 정의는 threads/thread.c에 제공되어 있습니다.
        
        int thread_get_nice (void);
        현재 스레드의 nice  값을 반환합니다.
        
        int thread_set_nice (int nice);
        현재 스레드의 nice 값을 새로운 nice 값으로 설정하고 새로운 값에 따라 스레드의 우선 순위를 다시 계산합니다 (우선 순위 계산 참조). 실행 중인 스레드가 더 이상 가장 높은 우선순위를 갖지 않으면 양보합니다.
        
    - Calculating Priority
        
        스케줄러에는 64개의 우선순위가 있으며, 따라서 0(PRI_MIN)에서 63(PRI_MAX)까지 64개의 준비 대기열이 있습니다. 숫자가 낮을수록 우선순위가 낮으므로 우선순위 0은 가장 낮은 우선순위이고 우선순위 63은 가장 높은 우선순위입니다. 스레드 우선순위는 스레드 초기화 시 처음에 계산됩니다. 또한 모든 스레드에 대해 네 번째 시계 틱마다 한 번씩 다시 계산됩니다. 두 경우 모두 공식에 의해 결정됩니다:
        
        → 우선순위 기부 대신에, 우선순위 계산시에 nice값을 사용하여 우선순위 높이는 모양
        
        ```c
        priority = PRI_MAX - (recent_cpu / 4) - (nice * 2),
        ```
        
        여기서 최근 cpu는 스레드가 최근에 사용한 CPU 시간의 추정치이며(아래 참조), nice는 스레드의 nice 값입니다. 결과는 가장 가까운 정수로 반내림(잘림)해야 합니다. 최근 CPU와 nice에 대한 계수 1/4과 2는 각각 실제로는 잘 작동하지만 더 깊은 의미는 없는 것으로 밝혀졌습니다. 계산된 우선순위는 항상 유효한 범위인 PRI_MIN에서 PRI_MAX에 속하도록 조정됩니다.
        
        이 공식은 최근에 CPU 시간을 받은 스레드가 다음에 스케줄러가 실행될 때 CPU를 다시 할당받을 때 우선순위를 낮게 부여합니다. 최근 CPU 시간을 받지 않은 스레드의 최근 CPU는 0이 되므로, 좋은 값이 높지 않으면 곧 CPU 시간을 받을 수 있습니다.
        
        → 최근 실행된 CPU는 우선순위가 낮아짐 즉, 순서밀림
        
        → 최근 CPU 시간을 받지 않은 경우, 높은 우선순위 부여, 즉 우선순위 높아짐
        
    - Calculating `recent_cpu`
        
        각 프로세스가 "최근" 얼마나 많은 CPU 시간을 받았는지 측정하려면 최근 CPU가 필요합니다. 또한, 더 세분화하기 위해 최근 `less`한 CPU 시간보다 최근 `more`한 CPU 시간에 더 큰 가중치를 부여해야 합니다. ~~한 가지 접근 방식은 n개의 요소 배열을 사용하여 지난 n초 동안 각각 받은 CPU 시간을 추적하는 것입니다. 그러나 이 접근 방식은 스레드당 O(n)의 공간과 새로운 가중 평균을 계산할 때마다 O(n)의 시간이 필요합니다.~~
        
        대신 다음과 같은 일반적인 형태의 기하급수적으로 가중된 이동 평균을 사용합니다:
        
        ```c
         x(0) = f(0),
        
        x(t) = ax(t − 1) + (1 − a)f(t),
        
        a = k/(k + 1),
        ```
        
        여기서 x(t)는 정수 시간 t ≥ 0에서의 이동 평균이고, f(t)는 평균을 구하는 함수이며, k > 0은 감쇠 속도를 제어합니다. 다음과 같이 몇 단계에 걸쳐 공식을 반복할 수 있습니다:
        
        ```c
        x(1) = f(1),
        
        x(2) = af(1) + f(2),
        
        ...
        
        x(5) = a^4 * f(1) + a^3 * f(2) + a^2 * f(3) + a * f(4) + f(5).
        ```
        
        f(t)의 값은 시간 t에서 1의 가중치를 가지며, 시간 t + 1에서 a의 가중치를 가지며, 시간 t + 2에서 a^2의 가중치를 가집니다. 또한 x(t)를 k와 연관시킬 수도 있습니다: f(t)는 시간 t + k에서 약 1/e, 시간 t + 2k에서 약 1/(e^2) 등의 가중치를 갖습니다. 반대 방향에서 보면, f(t)는 시간 t + log_a(w)에서 가중치 w로 감쇠합니다.
        
        recent_cpu의 초기 값은 처음 생성된 스레드에서는 0이고, 다른 새 스레드에서는 부모 스레드의 값입니다. 타이머 인터럽트가 발생할 때마다, `idle thread`가 실행 중이 아닌 한 실행 중인 스레드에 대해서만 recent_cpu가 1씩 증가합니다. 또한 초당 한 번씩 이 공식을 사용하여 모든 스레드(실행 중, 준비 중 또는 차단됨)에 대해 최근 CPU 값이 다시 계산됩니다:
        
        ```c
        recent_cpu = (2 * load_avg)/(2 * load_avg + 1) * recent_cpu + nice
        # recent 계수먼저 계산하고, load_avg 를 곱하자
        ```
        
        여기서 `load_avg`는 실행할 준비가 된 스레드 수의 이동(~~경쟁하고 있는 중, 레디에서 대기 중인~~) 평균입니다(아래 참조). `load_avg`가 1이면 평균적으로 하나의 스레드가 CPU를 놓고 경쟁하고 있음을 나타내며, recent cpu의 현재 값은 `log_(2/3) .1 ≈ 6`초 동안 `0.1`의 가중치로 감쇠하고, `load avg`가 `2`이면 `0.1`의 가중치로 감쇠하는 데 `log_(3/4) .1 ≈ 8초`가 걸립니다. 그 결과 최근 CPU는 스레드가 "최근" 받은 CPU 시간의 양을 추정하며, 감쇠 속도는 CPU를 놓고 경쟁하는 스레드 수에 반비례합니다.
        
        일부 테스트의 가정에 따르면 최근 CPU의 이러한 재계산은 시스템 틱 카운터가 1초의 배수에 도달할 때, 즉 `timer_ticks () % TIMER_FREQ == 0`이 될 때 정확히 이루어져야 하며 다른 시간에는 이루어지지 않아야 합니다.
        
        nice 값이 음수인 스레드의 경우 (우선순위가 높은)`recent_cpu`의 값은 음수일 수 있습니다. 음수 recent_cpu를 0으로 clamp(고정)하지 마세요.
        
        이 공식에서 계산 순서를 고려해야 할 수도 있습니다.  `recent_cpu` 계수를 먼저 계산한 다음 곱하는 것이 좋습니다. 일부 학생들은 `load_avg`에 `recent_cpu`를 직접 곱하면 오버플로가 발생할 수 있다고 보고했습니다.
        
        threads/thread.c에 스켈레톤이 있는 thread_get_recent_cpu()를 구현해야 합니다.
        
        ```c
        int thread_get_recent_cpu (void);
        # 현재 스레드의 최근 CPU 값의 100배를 가장 가까운 정수로 반올림하여 반환합니다.
        ```
        
    - Calculating `load_avg`
        
        마지막으로, 시스템 로드 평균이라고도 하는 `load avg`는 지난 1분 동안 ready-to-run 상태인 스레드의 평균 수를 추정합니다. `recent_cpu`와 마찬가지로 기하급수적으로 가중치가 부여된 이동 평균입니다. 우선순위 및 `recent_cpu`와 달리 `load_avg`는 스레드별이 아닌 시스템 전체에 적용됩니다. 시스템 부팅 시 0으로 초기화되며, 그 이후에는 초당 한 번씩 다음 공식에 따라 업데이트됩니다:
        
        → `load_avg` → 시스템 전체에 대해 → 시스템 부팅 시 0으로 초기화 → 초당 한번씩 업뎃
        
        → priority, `recent_cpu` → 스레드별로 → priority 네번째 시계틱마다 계산
        
        ```c
        load_avg = (59/60) * load_avg + (1/60) * ready_threads,
        ```
        
        여기서 `ready_threads`는 업데이트 시점에 실행 중이거나 실행할 준비가 된 스레드의 수입니다(`idle thread`제외).
        
        일부 테스트의 가정 때문에 `load_avg`는 시스템 틱 카운터가 1초의 배수에 도달할 때, 즉 timer_ticks () % TIMER_FREQ == 0일 때 정확히 업데이트해야 하며 다른 시점은 업데이트하지 않아야 합니다. threads/thread.c에 스켈레톤이 있는 thread_get_load_avg()를 구현해야 합니다.
        
        ```c
        int thread_get_load_avg (void)
        현재 시스템 로드 평균의 100배를 가장 가까운 정수로 반올림하여 반환합니다.
        ```
        
    - Summary
        
        다음 공식은 스케줄러를 구현하는 데 필요한 계산을 요약한 것입니다. 스케줄러 요구 사항에 대한 완전한 설명은 아닙니다.
        
        모든 스레드는 -20에서 20 사이의 값을 직접 제어합니다. 또한 각 스레드에는 0(`PRI_MIN`)에서 63(`PRI_MAX`) 사이의 우선 순위가 있으며, 이 우선 순위는 매 4번째 틱마다 다음 공식을 사용하여 다시 계산됩니다:
        
        ```c
        priority = PRI_MAX - (recent_cpu / 4) - (nice * 2)
        ```
        
        `recent_cpu`는 스레드가 "최근" 받은 CPU 시간을 측정합니다. 타이머가 틱할 때마다 실행 중인 스레드의 최근 CPU가 1씩 증가합니다. 초당 한 번씩 모든 스레드의 최근 CPU가 이러한 방식으로 업데이트됩니다:
        
        ```c
        recent_cpu = (2 * load_avg) / (2 * load_avg + 1) * recent_cpu + nice
        ```
        
        `load_avg`는 지난 1분 동안 실행할 준비가 된 스레드의 평균 수를 추정합니다. 부팅 시 0으로 초기화되고 다음과 같이 초당 한 번씩 다시 계산됩니다:
        
        ```c
        load_avg = (59/60) * load_avg + (1/60) * ready_threads
        ```
        
        여기서 `ready_threads`는 업데이트 시점에 실행 중이거나 실행할 준비가 된 스레드의 수입니다(유휴 스레드 제외).
        
    - Fixed-Point Real Arithmetic
        
        위의 공식에서 `priority`, `nice`, `ready_threads`는 정수이지만 `recent_cpu`와 `load_avg`는 실수입니다. 안타깝게도 핀토스는 커널에서 부동소수점 연산을 지원하지 않는데, 이는 커널을 복잡하게 만들고 속도를 저하시키기 때문입니다. 실제 커널도 같은 이유로 동일한 제한이 있는 경우가 많습니다. 즉, 실제 수량에 대한 계산은 정수를 사용하여 시뮬레이션해야 합니다. 이것은 어렵지 않지만 많은 학생들이 그 방법을 모릅니다. 이 섹션에서는 기본 사항을 설명합니다.
        
        기본 개념은 정수의 가장 오른쪽 비트를 분수를 나타내는 것으로 취급하는 것입니다. 예를 들어 부호가 붙은 32비트 정수의 최하위 14비트를 분수 비트로 지정하면 정수 x가 실수 `x/(2^14)`를 나타내게 됩니다. 소수점 앞에 17비트, 소수점 뒤에 14비트, 부호 비트가 하나씩 있기 때문에 이를 17.14 고정 소수점 숫자 표현이라고 합니다. 17.14 형식의 숫자는 최대 `(2^31 - 1)/(2^14) ≈ 131,071.999`의 값을 나타냅니다.
        
        `p.q` 고정 소수점 형식을 사용하고 있고 `f = 2^q`라고 가정합니다. 위의 정의에 따라 정수 또는 실수에 `f`를 곱하여 `p.q` 형식으로 변환할 수 있습니다. 예를 들어, 17.14 형식에서 위의 `load_avg` 계산에 사용된 분수 `59/60`은 `(59/60)2^14 = 16,110`입니다. 고정 소수점 값을 다시 정수로 변환하려면 `f`로 나눕니다. (C언어의  `/` 연산자는 0을 향해 반올림한다. 즉 양수는 내림하고 음수는 올림합니다. 가장 가까운 숫자로 반올림하려면, 나누기 전에 양수에 `f/2`를 더하거나 음수에 `f/2` 빼면 됩니다).
        
        고정 소수점 숫자에 대한 많은 연산은 간단합니다. `x`와 `y`를 고정 소수점 수로 하고 `n`을 정수로 합니다. 그러면 `x`와 `y`의 합은 `x + y`이고 그 차는 `x - y`입니다. 
        
        `x`와 `n`의 
        
        합은 `x + n * f`; 
        
        차, `x - n * f`; 
        
        곱, `x * n`; 
        
        몫, `x / n`입니다.
        
        두 개의 고정 소수점 값을 곱하는 데는 두 가지 복잡한 문제가 있습니다. 
        
        첫째, 결과의 소수점이 왼쪽으로 너무 멀리 떨어져 있습니다. `(59/60)(59/60)`은 `1`보다 약간 작아야 하지만 `16,111 × 16,111 = 259,564,321`은 `2^14 = 16,384`보다 훨씬 크다고 생각해보세요. `q` 비트를 오른쪽으로 이동하면 `259,564,321/2^14 = 15,842`, 즉 약 `0.97`이 정답이 됩니다. 
        
        둘째, 답이 표현 가능한데도 곱셈이 오버플로될 수 있습니다. 예를 들어 17.14 형식의 64는 64 × 2^14 = 1,048,576이고 그 제곱 64^2 = 4,096은 17.14 범위 내에 있지만 1,048,576^2 = 2^40으로 최대 부호 32비트 정수 값인 2^31 - 1보다 큽니다. 쉬운 해결책은 곱셈을 64비트 연산으로 하는 것입니다. 그러면 x와 y의 곱은 `((int64_t) x) * y / f`.
        
        두 개의 고정 소수점 값을 나누면 정반대의 문제가 발생합니다. 소수점이 너무 오른쪽에 위치하게 되는데, 이 문제는 나누기 전에 나누기 q 비트를 왼쪽으로 이동하여 해결합니다. 왼쪽으로 이동하면 나눗셈의 상위 q 비트가 버려지는데, 이 문제는 64비트로 나눗셈을 수행하여 다시 해결할 수 있습니다. 따라서 x를 y로 나눌 때의 몫은 `((int64_t) x) * f / y`.
        
        이 섹션에서는 두 가지 이유로 q-bit 시프트 대신 f로 곱셈 또는 나눗셈을 일관되게 사용했습니다. 
        
        첫째, 곱셈과 나눗셈에는 C 시프트 연산자와 같은 놀라운 연산자 우선 순위가 없습니다. 
        
        둘째, 곱셈과 나눗셈은 nagative operator에 대해 잘 정의되어 있지만 C 시프트 연산자는 그렇지 않습니다. 
        
        구현할 때 이러한 문제에 주의하세요.
        
        다음 표에는 C에서 고정 소수점 산술 연산을 구현하는 방법이 요약되어 있습니다. 표에서 x와 y는 고정 소수점 숫자이고, n은 정수이며, 고정 소수점은 부호가 있는 p.q 형식이고, p + q = 31이며, 
        
        `f`는 `1 << q`입니다:
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b278eae5-15fb-42de-a493-229718a0b327/b951cb63-de97-4138-8b50-264328e9600c/Untitled.png)
        
- APPENDIX
    - Threads
        - 들어가기
            - struct thread 구조체
            
            Pintos의 스레드에 대한 주요 데이터 구조는 threads/thread.h에 선언된 struct thread입니다.
            
            - struct thread;
            
            스레드나 사용자 프로세스를 나타냅니다. 프로젝트에서는 struct thread에 자체 멤버를 추가해야 합니다. 또한 기존 멤버의 정의를 변경하거나 삭제할 수도 있습니다. 각 struct thread는 자신의 메모리 페이지의 시작 부분을 차지합니다. 페이지의 나머지 부분은 해당 스레드의 스택으로 사용되며, 페이지의 끝부터 아래로 늘어납니다. 이것은 다음과 같이 보입니다: (아래 그림을 떠올리면 됩니다)
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b278eae5-15fb-42de-a493-229718a0b327/18b2a8e7-e419-48cd-9798-47e9781a6773/Untitled.png)
            
            이에는 두 가지 결과가 있습니다. 첫째, struct thread가 너무 커지지 않도록 해야 합니다. 만약 그렇게 된다면, 커널 스택에 충분한 공간이 확보되지 않을 것입니다. 기본적인 struct thread는 몇 바이트 크기입니다. 이는 아마도 1KB 미만으로 유지하는 것이 좋을 것입니다. 둘째, 커널 스택이 너무 커지지 않도록 해야 합니다. 스택이 넘치면 스레드 상태가 손상될 수 있습니다. 따라서 커널 함수에서는 비정적 로컬 변수로 큰 구조체나 배열을 할당하지 않아야 합니다. 대신 malloc()이나 palloc_get_page()와 같은 동적 할당을 사용해야 합니다 (Memory Allocation 참조).
            
        - 함수
            
            `tid_t tid;`
            
            스레드의 스레드 식별자 또는 tid(Thread ID)입니다. 모든 스레드는 커널 전체 수명 동안 고유해야 하는 tid를 가져야 합니다. 기본적으로 tid_t는 int에 대한 typedef로 정의되며, 각 새 스레드는 초기 프로세스를 위해 1부터 시작하여 숫자적으로 다음 더 높은 tid를 받게 됩니다. 원하는 경우 타입과 번호 매기기 방식을 변경할 수 있습니다.
            
            `enum thread_status status;`
            
            스레드의 상태는 다음 중 하나입니다:
            
            - THREAD_RUNNING
            
            해당 스레드가 실행 중입니다. 특정 시간에 정확히 하나의 스레드만이 실행됩니다. thread_current() 함수는 현재 실행 중인 스레드를 반환합니다.
            
            - THREAD_READY
            
            해당 스레드는 실행 준비가 되어 있지만, 현재 실행 중이 아닙니다. 다음으로 스케줄러가 호출될 때 해당 스레드가 실행될 수 있습니다. 실행 준비된 스레드들은 ready_list라는 이중 연결 리스트에 유지됩니다.
            
            - THREAD_BLOCKED
            
            해당 스레드는 무언가를 기다리고 있습니다. 예를 들어, 사용 가능한 잠금(lock)이나 인터럽트 호출을 기다리고 있을 수 있습니다. 해당 스레드는 thread_unblock()를 호출하여 THREAD_READY 상태로 전환되기 전까지 다시 스케줄되지 않습니다. 이것은 Pintos 동기화 기본 요소 중 하나를 사용하여 간접적으로 수행됩니다. (Synchronization 참조) 스레드가 무엇을 기다리고 있는지 사전에 알 방법은 없지만, 백트레이스(backtrace)는 도움이 될 수 있습니다. (Backtraces 참조)
            
            - thread block상태랑 thread ready상태가 뭐가 다른거야?
                
                `THREAD_BLOCKED` 상태와 `THREAD_READY` 상태의 차이는 다음과 같습니다:
                
                1. **THREAD_BLOCKED (블록된 상태)**:
                    - 스레드가 어떤 이벤트가 발생하기를 기다리거나, 리소스에 대한 접근을 기다리는 상태입니다. 예를 들어, 잠금(lock)을 얻기 위해 대기하거나 인터럽트를 기다리는 경우입니다.
                    - `THREAD_BLOCKED` 상태에 있는 스레드는 해당 이벤트가 발생하기 전까지 스케줄링되지 않습니다.
                    - 이 상태의 스레드는 `thread_unblock()`와 같은 함수를 통해 `THREAD_READY` 상태로 전환되어야 스케줄러에 의해 실행될 수 있습니다.
                2. **THREAD_READY (준비된 상태)**:
                    - 스레드가 실행 준비가 되어 있지만, 현재 실행 중이 아닌 상태입니다.
                    - `THREAD_READY` 상태의 스레드는 스케줄러가 호출되면 다음으로 실행될 수 있는 상태입니다. 즉, 스케줄러에 의해 언제든지 실행될 수 있는 상태입니다.
                    - 준비된 스레드들은 스케줄러에 의해 선택될 때 다음 실행될 수 있습니다.
                
                요약하자면, `THREAD_BLOCKED` 상태의 스레드는 어떤 이벤트가 발생하기를 기다리면서 실행이 중단된 상태이며, 이벤트가 발생하면 `THREAD_READY` 상태로 전환되어 스케줄러에 의해 실행될 수 있게 됩니다. `THREAD_READY` 상태의 스레드는 실행 준비가 되어 있지만, 스케줄러에 의해 언제든지 선택되어 실행될 수 있는 상태입니다.
                
            - THREAD_DYING
            
            해당 스레드는 스케줄러에 의해 다음 스레드로 전환된 후에 파괴될 예정입니다.
            
            `char name[16];`
            
            스레드의 이름은 문자열 형태로 표현되며, 적어도 처음 몇 개의 문자로 구성됩니다. 이름은 해당 스레드를 식별하기 위한 문자열로 사용됩니다. 이름은 스레드를 이해하고 관리하는 데 도움이 되는 정보를 제공합니다. 이 정보는 주로 디버깅이나 스레드 추적을 위해 사용됩니다.
            
            `struct intr_frame tf;`
            
            컨텍스트 스위칭을 위한 정보는 주로 레지스터 값 및 스택 포인터와 관련된 정보를 포함합니다. 이 정보는 스레드가 실행되는 동안 레지스터에 저장된 값들과 스택 메모리에 대한 포인터 등을 포함합니다.
            
            (———-아래는 GPT——--)
            
            1. **레지스터 값**: 스레드의 현재 실행 상태를 나타내는 레지스터 값은 컨텍스트 스위칭에서 중요한 역할을 합니다. CPU 레지스터에는 프로그램 카운터(PC)///, 스택 포인터(SP)////, 베이스 포인터(BP), 데이터 레지스터 등이 포함될 수 있으며, 스레드의 실행 상태를 유지하는 데 필요한 값들이 포함됩니다.
            2. **스택 포인터**: 스레드의 스택 메모리에 대한 포인터는 해당 스레드의 스택 프레임에 대한 위치 정보를 나타냅니다. 컨텍스트 스위칭 시에는 다음으로 실행될 스레드의 스택 프레임으로 스택 포인터를 변경하여 해당 스레드의 상태를 재현합니다.
            
            이러한 정보는 컨텍스트 스위칭 동안 스레드 상태를 보존하고 복원하는 데 사용되며, 이를 통해 여러 스레드 간의 전환이 원활하게 이루어질 수 있습니다.
            
            (—————————————-)
            
            `int priority;`
            스레드의 우선 순위를 나타내며, PRI_MIN(0)에서 PRI_MAX(63)까지의 범위를 가집니다. 낮은 숫자는 낮은 우선 순위를 의미합니다. 즉, priority 0이 가장 낮은 우선 순위이고, priority 63이 가장 높은 우선 순위입니다. Pintos는 기본적으로 스레드 우선 순위를 무시하지만, Project 1에서 우선 순위 스케줄링을 구현할 것입니다. (우선 순위 스케줄링 참조)
            
            `struct list_elem elem;`
            "리스트 요소"로, 스레드를 이중 연결 리스트에 넣는 데 사용됩니다. ready_list(실행 준비가 된 스레드의 리스트)나 sema_down()에서 세마포어를 기다리는 스레드의 리스트에 스레드를 배치하는 데 사용됩니다. 이는 스레드가 세마포어를 기다리는 경우에는 실행 준비 상태가 아니며, 그 반대의 경우에도 사용될 수 있습니다.
            
            `uint64_t *pml4;`
            Project 2 이후에만 존재합니다. 페이지 테이블(Page Tables)을 참조하세요.
            
            `unsigned magic`
            언제나 THREAD_MAGIC로 설정됩니다. THREAD_MAGIC은 threads/thread.c에서 정의된 임의의 숫자이며, 스택 오버플로우를 감지하는 데 사용됩니다. thread_current() 함수는 현재 실행 중인 스레드의 struct thread의 magic 멤버가 THREAD_MAGIC으로 설정되어 있는지 확인합니다. 스택 오버플로우가 발생하면 이 값이 변경되어 어서션(assertion)을 트리거합니다. struct thread에 멤버를 추가할 때는, magic을 마지막에 둔 채로 사용하는 것이 좋습니다.
            
    - Synchronization
        - 들어가기
            
            `threads/thread.c` implements several public functions for thread support. Let's take a look at the most useful:
            
        - 함수
            
            `void thread_init (void);`
            main()에서 호출되어 스레드 시스템을 초기화합니다. 주요 목적은 Pintos 초기 스레드를 위한 struct thread를 생성하는 것입니다. Pintos 로더(loader)가 초기 스레드의 스택을 페이지 맨 위에 놓기 때문에 가능합니다. 다른 Pintos 스레드와 동일한 위치에 초기 스레드의 스택이 배치됩니다.
            
            thread_init()가 실행되기 전에 thread_current()는 실패합니다. lock_acquire()와 같은 많은 함수들이 직접 또는 간접적으로 thread_current()를 호출하므로, Pintos 초기화 과정에서 thread_init()가 초기에 호출됩니다.
            
            `void thread_start (void);`
            main()에서 호출되어 스케줄러를 시작합니다. idle 스레드를 생성하며, 이는 다른 스레드가 준비되지 않은 상황에서 스케줄되는 스레드입니다. 그런 다음 인터럽트를 활성화하는데, 이로 인해 스케줄러도 활성화됩니다. 이는 스케줄러가 타이머 인터럽트에서 반환되어 실행되기 때문입니다(intr_yield_on_return()를 사용).
            
            `void thread_start (void);`
            타이머 인터럽트에서 매 타이머 tick마다 호출됩니다. 스레드 통계를 추적하고, 타임 슬라이스가 만료되면 스케줄러를 트리거합니다.
            
            `void thread_print_stats (void);`
            Pintos 종료 시에 스레드 통계를 출력하기 위해 호출됩니다.
            
            tid_t thread_create (const char *name, int priority, thread func *func, void *aux);
            스레드를 생성하여 해당 스레드의 식별자(tid)를 반환합니다. 이름, 우선 순위, 실행 함수, 보조(auxiliary) 데이터를 전달받습니다.
            
            주어진 우선 순위로 이름이 name인 새로운 스레드를 생성하고 시작하여, 새로운 스레드의 tid를 반환합니다. 이 스레드는 aux를 함수의 단일 인자로 전달하여 func을 실행합니다.
            
            thread_create() 함수는 스레드의 struct thread와 스택을 위한 페이지를 할당하고, 멤버들을 초기화한 다음, 가짜 스택 프레임을 설정합니다. 이 스레드는 블록된 상태에서 초기화되고, 반환 직전에 unblock되어, 새로운 스레드가 스케줄될 수 있게 됩니다.
            
            `void thread_func (void *aux);`
            이것은 thread_create()에 전달되는 함수의 유형입니다. aux 인자는 함수의 단일 인자로 전달됩니다.
            
            `void thread_block (void);`
            실행 중인 스레드를 실행 중인 상태에서 블록된 상태로 전환합니다. thread_unblock()이 호출되기 전까지 해당 스레드는 다시 실행되지 않습니다. 따라서 이에 대한 방법이 미리 정리되어 있어야 합니다. 이는 매우 저수준의 함수이므로 동기화 원시(primitives)를 사용하는 것이 좋습니다(동기화 참조).
            
            `void thread_unblock (struct thread *thread);`
            blocked 상태에 있는 스레드를 ready 상태로 전환하여, 해당 스레드가 실행되도록 합니다. 이는 스레드가 기다리고 있는 이벤트(예: 스레드가 대기 중인 lock이 사용 가능해질 때)가 발생했을 때 호출됩니다.
            
            `struct thread *thread_current (void);`
            현재 실행 중인 스레드를 반환합니다.
            
            `tid_t thread_tid (void);`
            현재 실행 중인 스레드의 스레드 ID를 반환합니다. thread_current ()->tid와 동일합니다.
            
            `const char *thread_name (void);`
            현재 실행 중인 스레드의 이름을 반환합니다. thread_current ()->name과 동일합니다.
            
            `void thread_exit (void) NO_RETURN;`
            현재 스레드를 종료시킵니다. 반환되지 않습니다.
            
            `void thread_yield (void);`
            CPU를 스케줄러에 양보하여, 새로운 스레드를 선택하도록 합니다. 새로운 스레드가 현재 스레드일 수 있으므로, 특정 시간 동안 현재 스레드를 실행하지 않을 것으로 확신할 수는 없습니다.
            
            스레드 우선 순위를 설정하고 가져오는 스텁(Stub)입니다. 우선 순위 스케줄링을 참조하세요.
            
            ```
            int thread_get_priority (void);
            void thread_set_priority (int new_priority);
            ```
            
            int thread_get_nice (void);
            void thread_set_nice (int new_nice);
            int thread_get_recent_cpu (void);
            int thread_get_load_avg (void);
            고급 스케줄러를 위한 스텁(Stub)입니다. 각각 nice 값 설정/가져오기,최근 CPU 사용량 및 부하 평균값을 가져오는 기능을 제공합니다.
            
