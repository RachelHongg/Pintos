# PROJECT2:USER PROGRAMS

- Introduction
    - 들어가기
        
        이제 핀토스로 작업하고 핀토스의 인프라와 스레드 패키지에 익숙해졌으므로 이제 사용자 프로그램을 실행할 수 있는 시스템 부분에 대한 작업을 시작할 차례입니다. 기본 코드는 이미 사용자 프로그램의 로딩과 실행을 지원하지만 I/O 또는 상호 작용은 불가능합니다. 이 프로젝트에서는 프로그램이 시스템 콜을 통해 OS와 상호 작용할 수 있도록 할 것입니다. 이 과제를 위해 `userprog`디렉터리에서 작업하게 되지만, 핀토스의 거의 모든 다른 부분과도 상호 작용하게 될 것입니다. 아래에서 관련 부분을 설명하겠습니다.
        
        **프로젝트 1 제출물 위에 프로젝트 2를 빌드**해야 합니다. 프로젝트 1의 코드가 프로젝트 2의 코드에 영향을 미치지는 않지만, 프로젝트 2은 증분(incremental) 프로젝트이므로 프로젝트 1의 테스트 케이스를 통과해야 합니다.
        
        또한 프로젝트 2에서 추가 도전 과제가 있음을 알아주세요. **이것은 선택적 구현일 뿐입니다.** 또한 추가 챌린지의 경우 테스트 케이스를 제외한 어떠한 스켈레톤 코드도 제공되지 않습니다. 모든 디자인은 여러분의 몫입니다. 추가 요구 사항을 제출하고 테스트하려면 userprog/Make.vars를 편집해야 합니다.
        
        <aside>
        💡 추가 도전 과제는 
        1) 테스트 케이스 이외의 뼈대 코드는 제공X
        2) 제출과 테스트 위해선 userprog/Make.vars를 편집해야
        
        </aside>
        
        마지막으로, TODO가 없는 코드라고 해서 항상 해당 코드를 변경할 필요없는 게  아니라는 점에 유의하세요. 테스트 코드를 제외한 프로젝트2의 모든 소스 코드를 자유롭게 수정할 수 있습니다.
        
        <aside>
        💡 프로젝트2의 소스코드 다 바꿀 수 있음!
        
        </aside>
        
    - Background
        
        지금까지 핀토스에서 실행한 모든 코드는 운영 체제 커널의 일부였습니다. 예를 들어, 마지막 과제의 모든 테스트 코드는 커널의 일부로 실행되어 시스템의 권한 있는 부분에 대한 전체 액세스 권한을 가졌음을 의미합니다. 운영 체제 위에서 사용자 프로그램을 실행하기 시작하면 더 이상 그렇지 않습니다. 이 프로젝트는 그 결과를 다룹니다.
        
        한 번에 하나 이상의 프로세스를 실행할 수 있습니다. 각 프로세스에는 하나의 스레드가 있습니다(멀티스레드 프로세스는 지원되지 않음). 사용자 프로그램은 컴퓨터 전체를 가지고 있다는 착각 하에 작성됩니다. 즉, 한 번에 여러 프로세스를 로드하고 실행할 때 이러한 착각을 유지하기 위해 메모리, 스케줄링 및 기타 상태를 올바르게 관리해야 합니다.
        
        이전 프로젝트에서는 테스트 코드를 커널에 직접 컴파일했기 때문에 커널 내 특정 함수 인터페이스가 필요했습니다. 이제부터는 사용자 프로그램을 실행하여 운영 체제를 테스트할 것입니다. 이렇게 하면 훨씬 더 자유로워집니다. 사용자 프로그램 인터페이스가 여기에 설명된 사양을 충족하는지 확인해야 하지만, 이러한 제약이 있으므로 커널 코드를 원하는 대로 자유롭게 재구성하거나 재작성할 수 있습니다. 모든 코드는 `#ifdef VM`으로 둘러싸인 블록에 위치하지 않아야 합니다. 이 블록은 프로젝트 3에서 구현할 가상 메모리 서브시스템을 활성화한 후에 포함될 것입니다. 또한 코드가 `#ifndef VM`으로 둘러싸인 경우 해당 코드는 프로젝트 3에서 생략됩니다.
        
        시작하기 전에 `동기화` 및 `가상 주소`를 읽어보시기 바랍니다.
        
    - Source Files
        
        작업할 프로그래밍의 개요를 파악하는 가장 쉬운 방법은 작업할 각 부분을 간단히 살펴보는 것입니다. `userprog`에서는 소수의 파일을 찾을 수 있지만 대부분의 작업은 여기에 있습니다:
        
        - `process.c`, `process.h`
            
            ELF 바이너리를 로드하고 프로세스를 시작합니다.
            
            - ELF 바이너리
                
                → ELF(Executable and Linkable Format) 컴퓨터 시스템에서 실행 가능한 프로그램을 위한 파일 형식 중 하나입니다. ELF는 주로 UNIX 및 UNIX 계열 운영 체제에서 사용되며, Linux 시스템에서 실행 파일, 라이브러리, 코어 덤프(core dump) 등을 저장하는 데 사용됩니다.
                
                → 바이너리 형식(Binary format)은 컴퓨터에서 데이터를 저장하고 처리하는 방식을 나타냅니다. 컴퓨터는 숫자를 0과 1로 표현하는 이진(binary) 형태
                
        - `syscall.c`, `syscall.h`
            
            사용자 프로세스가 일부 커널 기능에 액세스하려고 할 때마다 시스템 콜을 호출합니다. 이것은 스켈레톤 시스템 콜 핸들러입니다. 현재는 메시지를 출력하고 사용자 프로세스를 종료하기만 합니다. 이 프로젝트의 2부에서는 시스템 콜에 필요한 다른 모든 작업을 수행하는 코드를 추가할 것입니다.
            
        - `syscall-entry.S` → 이해할 필요X
            
            시스템 콜 핸들러를 부트스트랩하는 작은 어셈블리 코드입니다. 이 코드를 이해할 필요는 없습니다.
            
        - `exception.c`, `exception.h`
            
            사용자 프로세스가 권한이 있거나 금지된 작업을 수행하면 예외 또는 오류로 커널에 트래핑됩니다. 이 파일들은 예외를 처리합니다. 현재 모든 예외는 단순히 메시지를 출력하고 프로세스를 종료합니다. 프로젝트 2의 일부 솔루션(전부는 아니지만)은 이 파일에서 page_fault()를 수정해야 합니다.
            
            <aside>
            🤍 프로젝트 2의 일부 솔루션(전부는 아니지만)은 이 파일에서 page_fault()를 수정해야
            
            </aside>
            
        - `GDT.C`, `GDT.H` → 수정할 필요 X
            
            x86-64는 세그먼트 아키텍처입니다. 글로벌 디스크립터 테이블(GDT)은 사용 중인 세그먼트를 설명하는 테이블입니다. 이 파일들은 GDT를 설정합니다. 어떤 프로젝트에서도 이 파일을 수정할 필요가 없습니다. GDT의 작동 방식이 궁금하다면 코드를 읽어보세요.
            
        - `tss.c`, `tss.h`
            
            작업 상태 세그먼트(Task State Segment, TSS)는 x86 아키텍처 작업 전환에 사용되었습니다. 그러나 x86-64에서는 작업 전환이 더 이상 사용되지 않습니다. 그럼에도 불구하고 링 전환 중에 스택 포인터를 찾기 위해 TSS는 여전히 존재합니다.
            
            즉, 사용자 프로세스가 인터럽트 핸들러에 진입하면 하드웨어는 커널의 스택 포인터를 조회하기 위해 tss를 참조합니다. 어떤 프로젝트에 대해서도 이러한 파일을 수정할 필요가 없습니다. TSS의 작동 방식이 궁금하다면 코드를 읽어보세요.
            
            - TSS
                
                x86 아키텍처에서는 작업 상태 세그먼트(Task State Segment, TSS)가 프로세스의 상태 정보를 저장하고 작업 전환을 지원하는 데 사용되었습니다. TSS는 주로 태스크 스위칭(Task Switching) 시에 사용되었습니다. 이전에는 태스크 스위칭이 사용되어 멀티태스킹을 지원하기 위해 프로세스 간에 상태를 저장하고 복원하는 데 TSS가 중요한 역할을 했습니다.
                
                그러나 x86-64 아키텍처에서는 롱 모드(Long Mode)라고도 알려진 64비트 모드로 진화하면서, 실제로 TSS를 사용하는 것은 크게 감소했습니다. 이는 x86-64에서 태스크 스위칭이 더 이상 일반적으로 사용되지 않기 때문입니다.
                
                그럼에도 불구하고, TSS가 x86-64에서 여전히 존재하는 이유는 일부 특정한 기능과 호환성 때문입니다. 특히, 링 전환 중에 스택 포인터를 찾기 위해 TSS가 여전히 사용됩니다. 링 전환이란 커널 모드(Kernel Mode)에서 유저 모드(User Mode)로 전환될 때 스택 포인터가 변경되는데, 이때 TSS의 링 전환 필드를 통해 스택 포인터를 찾을 수 있습니다. 따라서 이러한 특정한 목적을 위해 TSS는 여전히 일부 시스템에서 유용하게 사용됩니다.
                
                그러나 대부분의 운영 체제 및 응용 프로그램에서는 태스크 스위칭을 위해 TSS를 사용하지 않고, 대신에 다른 메커니즘을 사용합니다. 따라서 현대 시스템에서는 TSS가 필수적이지 않을 수 있지만, 일부 특정한 상황에서 여전히 유용하게 활용될 수 있습니다.
                
    - Using the File System
        
        사용자 프로그램이 파일 시스템에서 로드되고 구현해야 하는 많은 시스템 호출이 파일 시스템을 다루기 때문에 이 프로젝트에서는 파일 시스템 코드에 인터페이스해야 합니다. 하지만 이 프로젝트의 초점은 파일 시스템이 아니므로 filesys 디렉터리에 간단하지만 완전한 파일 시스템을 제공했습니다. 파일 시스템 사용 방법, 특히 파일 시스템의 여러 가지 제한 사항을 이해하려면 `filesys.h`및 `file.h`인터페이스를 살펴보는 것이 좋습니다.
        
        이 프로젝트의 파일 시스템 코드를 수정할 필요는 없으므로 수정하지 않는 것이 좋습니다. 파일 시스템에서 작업하면 이 프로젝트의 초점이 흐트러질 수 있습니다.
        
        지금 파일 시스템 루틴을 적절히 사용하면 파일 시스템 구현을 개선할 때 프로젝트 4를 훨씬 더 쉽게 수행할 수 있습니다. 그때까지는 다음과 같은 **제한 사항**을 감수해야 합니다:
        
        - 내부 동기화 없음. 동시 액세스가 서로 간섭을 일으킬 수 있습니다. 동기화를 사용하여 한 번에 하나의 프로세스만 파일 시스템 코드를 실행하도록 해야 합니다.
        - 파일 크기는 생성 시 고정됩니다. 루트 디렉터리는 파일로 표시되므로 생성할 수 있는 파일 수 또한 제한됩니다.
        - 파일 데이터는 단일 범위로 할당됩니다. 즉, 단일 파일의 데이터는 디스크의 연속된 섹터 범위를 차지해야 합니다. 따라서 파일 시스템을 오래 사용하면 외부 단편화(External fragmentation)가 심각한 문제가 될 수 있습니다.
        - 하위 디렉터리 없음
        - 파일 이름은 14자로 제한됩니다.
        - 작동 중 시스템 충돌이 발생하면 자동으로 복구할 수 없는 방식으로 디스크가 손상될 수 있습니다. 파일 시스템 복구 도구가 없습니다.
        
        한 가지 중요한 기능이 포함되어 있습니다:
        
        `filesys_remove()`에 대한 유닉스와 유사한 의미론이 구현되었습니다. 즉, 파일이 제거될 때 열려 있는 경우 해당 블록은 할당 해제되지 않으며 마지막 스레드가 파일을 닫을 때까지 / 열려 있는 모든 스레드에서 계속 액세스할 수 있습니다. 자세한 내용은 열린 파일 제거하기(FAQ)를 참조하세요.
        
        ---
        
        모든 테스트 프로그램이 커널 이미지에 이미 존재했던 프로젝트 1과 달리, 테스트 프로그램(사용자 공간에서 실행되는)을 핀토스 가상 머신에 넣어야 합니다. 사용자의 편의를 위해 테스트 스크립트(예: make check)가 이 작업을 자동으로 처리하므로 대부분의 경우 이를 이해할 필요가 없습니다. 하지만 이를 알고 있으면 개별 테스트 사례를 실행하는 데 큰 도움이 됩니다.
        
        핀토스 가상 머신에 파일을 넣으려면 먼저 파일 시스템 파티션이 있는 시뮬레이션 디스크를 만들 수 있어야 합니다. `pintos-mkdisk` 프로그램이 이 기능을 제공합니다. `userprog/build` 디렉토리에서 `pintos-mkdisk filesys.dsk 2`를 실행합니다. 이 명령은 2MB 핀토스 파일 시스템 파티션이 포함된 `filesys.dsk`라는 이름의 시뮬레이션 디스크를 생성합니다. 그런 다음  `--fs-disk filesys.dsk` 뒤에 `--`를 전달하여 디스크를 지정합니다(예: `pintos --fs-disk filesys.disk -- KERNEL_COMMANDS...`). 이 `--`은 `--fs-disk`가 시뮬레이션된 커널이 아닌 핀토스 스크립트를 위한 것이기 때문에 필요합니다. 그런 다음 커널의 명령줄에 `-f -q`를 전달하여 파일 시스템 파티션을 포맷합니다: `pintos SCRIPT_COMMANDS -- -f -q`. `-f` 옵션은 파일 시스템을 포맷하도록 하고, `-q`는 포맷이 완료되는 즉시 Pintos를 종료하도록 합니다.
        
        시뮬레이션 된 파일 시스템 안팎으로 파일을 복사하는 방법이 필요합니다. 핀토스 -p("put;넣다") 및 -g("get;얻다") 옵션이 이 작업을 수행합니다. `file`을 Pintos 파일 시스템으로 복사하려면 `pintos -p file -- -q` 명령을 사용합니다. `newname`이라는 이름으로 Pintos 파일 시스템에 복사하려면 원래 파일 이름 뒤에 `:newname`을 추가합니다: `pintos -p file:newname -- -q`. VM에서 파일을 복사하는 명령은 비슷하지만 `-p` 대신 `-g`로 대체합니다.
        
        참고로, 이러한 명령은 커널의 명령줄에 특수 명령 추출 및 추가를 전달하고 시뮬레이션된 특수 "스크래치" 파티션**에** 복사, 파티션**으로부터** 복사(copying to and from) 하는 방식으로 작동합니다. 궁금한 점이 많으시다면 pintos 스크립트와 `filesys/fsutil.c`에서 구현 세부 사항을 확인할 수 있습니다.
        
        다음은 파일 시스템 파티션이 있는 디스크를 만들고, / 파일 시스템을 포맷하고, / *args-single* 프로그램(이 프로젝트의 두 번째 테스트 케이스)를 새 디스크에 복사한 다음, / 인수 'onearg'를 전달하여 실행하는 방법을 **요약**한 것입니다. (인자 전달은 구현하기 전까지는 작동하지 않습니다.) 테스트 케이스를 이미 빌드했고 현재 디렉터리가 `userprog/build`라고 가정합니다:
        
        ```c
        pintos-mkdisk filesys.dsk 10  //10MB 시뮬레이션 디스크 생성
        pintos --fs-disk filesys.dsk -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
        ```
        
        나중에 사용하거나 검사하기 위해 파일 시스템 디스크를 보관하고 싶지 않다면 네 단계를 모두 단일 명령으로 결합할 수도 있습니다. `--filesys-size=n` 옵션은 핀토스를 실행하는 동안만 약 n메가바이트 크기의 임시 파일 시스템 파티션을 생성합니다. 핀토스 자동 테스트 스위트는 이 구문을 광범위하게 사용합니다:
        
        ```c
        pintos --fs-disk=10 -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'
        ```
        
    - How User Programs Work
        
        핀토스는 메모리에 맞고(fit) 사용자가 구현한 시스템 콜만 사용하는 한 일반 C 프로그램을 실행할 수 있습니다. 특히 이 프로젝트에 필요한 시스템 콜 중 메모리 할당을 허용하는 것이 없기 때문에 `malloc()`을 구현할 수 없습니다. 또한 핀토스는 스레드를 전환할 때 커널이 프로세서의 부동 소수점 단위를 저장 및 복원하지 않기 때문에 부동 소수점 연산을 사용하는 프로그램을 실행할 수 없습니다.
        
        Pintos는 `userprog/process.c`에 제공된 로더를 사용하여 ELF 실행 파일을 로드할 수 있습니다. ELF는 Linux, Solaris 및 기타 여러 운영 체제에서 객체 파일, 공유 라이브러리 및 실행 파일에 사용하는 파일 형식입니다.
        
        실제로 x86-64 ELF 실행 파일을 출력하는 모든 컴파일러와 링커를 사용하여 핀토스용 프로그램을 생성할 수 있습니다. (저희가 제공한 컴파일러와 링커는 잘 작동합니다.) 테스트 프로그램을 시뮬레이션된 파일 시스템에 복사하기 전까지는 Pintos에서 유용한 작업을 수행할 수 없다는 점을 즉시 인식해야 합니다. 다양한 프로그램을 파일 시스템에 복사하기 전까지는 흥미로운 작업을 할 수 없습니다. 디버깅하는 동안 파일을  `filesys.disk` 를 쓸모 없는 상태로를 비우는 일이 가끔 일어나는데, 이 때마다 깨끗한 참조 파일 시스템 디스크를 만들어 복사하는 것이 좋을 것이다.
        
    - Virtual Memory Layout
        
        핀토스의 가상 메모리는 사용자 가상 메모리와 커널 가상 메모리의 두 영역으로 나뉩니다. 사용자 가상 메모리는 가상 주소 `0`에서 `KERN_BASE`까지입니다. 이것은 `include/threads/vaddr.h`에 정의되어 있고 기본값은 `0x8004000000`입니다. 커널 가상 메모리는 나머지 가상 주소 공간을 차지합니다.
        
        사용자 가상 메모리는 프로세스별입니다. 커널이 한 프로세스에서 다른 프로세스로 전환할 때 프로세서의 페이지 디렉터리 베이스 레지스터를 변경하여 사용자 가상 주소 공간도 전환합니다(`thread/mmu.c`의 `pml4_activate()` 참조). 스레드 구조체에는 프로세스의 페이지 테이블에 대한 포인터가 포함되어 있습니다.(p788, 다중 레벨 페이지 테이블)
        
        커널 가상 메모리는 전역적입니다. 실행 중인 사용자 프로세스나 커널 스레드에 관계없이 항상 같은 방식으로 매핑됩니다. 핀토스에서 커널 가상 메모리는 `KERN_BASE`에서 시작하여 물리적 메모리에 일대일로 매핑됩니다. 즉, 가상 주소 `KERN_BASE`는 물리적 주소 `0`에 액세스하고, 가상 주소 `KERN_BASE + 0x1234`는 물리적 주소 `0x1234`에 액세스하는 식으로 머신의 물리적 메모리 크기까지 액세스합니다.(p799)
        
        사용자 프로그램은 자신의 사용자 가상 메모리에만 액세스할 수 있습니다. 커널 가상 메모리에 액세스를 시도하면 `userprog/exception.c`의 `page_fault()`가 처리하는 페이지 오류가 발생하고 프로세스가 종료됩니다. 커널 스레드는 커널 가상 메모리와 사용자 프로세스가 실행 중인 경우/ 실행 중인 프로세스의 사용자 가상 메모리에 모두 액세스할 수 있습니다. /그러나 커널에서도 매핑되지 않은 사용자 가상 주소로 메모리에 액세스하려고 시도하면 page fault가 발생합니다.
        
        <aside>
        🤍 page_fault()가 발생하는 이유? (아래의 Accessing User Memory와 같이 보기)
        1) 
        사용자 프로그램이 커널 가상 메모리에 엑세스 시도할 경우, 
        (원래는 커널 가상 메모리와 사용자 프로세스가 동시에 실행중인 경우에만 엑세스 가능) 
        → 보안성, 신뢰성 문제
        2) 
        매핑되지 않은 사용자 가상 주소로 메모리에 엑세스 시도할 경우
        
        </aside>
        
    - Typical Memory Layout
        
        개념적으로 각 프로세스는 자체 사용자 가상 메모리를 원하는 대로 자유롭게 배치할 수 있습니다. 실제로 사용자 가상 메모리는 다음과 같이 배치됩니다:
        
        ```c
        USER_STACK +----------------------------------+
                   |             user stack           |
                   |                 |                |
                   |                 |                |
                   |                 V                |
                   |           grows downward         |
                   |                                  |
                   |                                  |
                   |                                  |
                   |                                  |
                   |           grows upward           |
                   |                 ^                |
                   |                 |                |
                   |                 |                |
                   +----------------------------------+
                   | uninitialized data segment (BSS) |
                   +----------------------------------+
                   |     initialized data segment     |
                   +----------------------------------+
                   |            code segment          |
         0x400000  +----------------------------------+
                   |                                  |
                   |                                  |
                   |                                  |
                   |                                  |
                   |                                  |
               0   +----------------------------------+
        ```
        
        이 프로젝트에서는 사용자 스택의 크기가 고정되어 있지만 프로젝트 3에서는 크기가 커질 수 있습니다. 기존에는 초기화되지 않은 데이터 세그먼트의 크기를 시스템 호출로 조정할 수 있었지만, 앞으로는 이를 구현할 필요가 없습니다.
        
        핀토스의 코드 세그먼트는 사용자 가상 주소 `0x400000`에서 시작하며, 주소 공간 하단에서 약 128MB입니다. 이 값은 우분투의 일반적인 값으로 큰 의미는 없습니다.
        
        링커는 다양한 프로그램 세그먼트의 이름과 위치를 알려주는 "링커 스크립트"의 지시에 따라 메모리에서 사용자 프로그램의 레이아웃을 설정합니다. 링커 스크립트에 대한 자세한 내용은 링커 매뉴얼의 "스크립트" 챕터(`info ld`를 통해 액세스할 수 있음)를 참조하세요.
        
        특정 실행 파일의 레이아웃을 보려면 `-p` 옵션과 함께 objdump를 실행합니다.
        
    - Accessing User Memory
        
        시스템 콜의 일부로 커널은 종종 사용자 프로그램에서 제공하는 포인터를 통해 메모리에 액세스해야 합니다. 사용자가 1)널 포인터, 2)매핑되지 않은 가상 메모리에 대한 포인터 또는 3)커널 가상 주소 공간(KERN_BASE 위)에 대한 포인터를 전달할 수 있으므로 커널은 이 때 매우 주의를 기울여야 합니다. 이러한 모든 유형의 잘못된 포인터는 커널이나 실행 중인 다른 프로세스에 피해를 주지 않으면서 **문제가 되는 프로세스를 종료하고 해당 리소스를 해제하여 거부해야** 합니다.
        
        <aside>
        🤍 Accessing User Memory 영역에 접근하는 경우?
        1) 사용자가 널 포인터에 접근 
        ~~*→ 핀토스 안의 함수가 알아서 걸러줌…! → 우리가 처리해줄 필요 없음…!*~~
        → 각 자료형마다 널포인터를 나타내기 위한 쓰레기 메모리 영역이 있음. 
        그 부분을 가리키면 널 포인터가 됨.
        2) 매핑되지 않은 가상 메모리에 대한 포인터
        → page_fault() 발생
        3) 커널 가상 주소 공간 (보안성, 신뢰성)
        → page_fault() 발생
        
        </aside>
        
        이를 올바르게 수행하는 데는 적어도 두 가지 합리적인 방법이 있습니다. 
        
        첫 번째 방법은 사용자가 제공한 포인터의 유효성을 확인한 다음 포인터를 참조 해제(dereference;역참조; * 연산자)하는 것입니다. 이 방법을 선택하면 `thread/mmu.c`와 `include/threads/vaddr.h`의 함수를 살펴볼 수 있습니다. 이는 사용자 메모리 액세스를 처리하는 가장 간단한 방법입니다.
        
        ```c
        /* 
        * mmu.c 파일 
        * pml4안에 있는 사용자 UADDR 가상 주소와 대응되는 물리 주소를 찾는 함수
        * 물리 주소와 대응되는 커널의 가상 주소를 반환
        * UADDR이 매핑이 되지 않았으면, 널 포인터를 반환
        */
        void *
        pml4_get_page (uint64_t *pml4, const void *uaddr) {
        	ASSERT (is_user_vaddr (uaddr));     // 포인터 유효성 확인
        
        	uint64_t *pte = pml4e_walk (pml4, (uint64_t) uaddr, 0);   // 역참조
        
        	if (pte && (*pte & PTE_P))
        		return ptov (PTE_ADDR (*pte)) + pg_ofs (uaddr);
        	return NULL;
        }
        
        /* vaddr.h 파일
        * VADDR이 사용자 가상 주소이면 true를 반환 
        */
        #define is_user_vaddr(vaddr) (!is_kernel_vaddr((vaddr)))
        ```
        
        두 번째 방법은 사용자 포인터가 `KERN_BASE`아래를 가리키는지만 확인한 다음 이를 역참조(dereference)하는 것입니다. 잘못된 사용자 포인터는 "**페이지 오류**"를 발생시키며, 이 오류는 `userprog/exception.c`에서 `page_fault()`의 코드를 수정하여 처리할 수 있습니다. 이 기술은 프로세서의 **MMU를 활용**하기 때문에 일반적으로 더 빠르므로 실제 커널(Linux 포함)에서 사용되는 경향이 있습니다. (더 빨라서 첫번째 방법보다는 좋을듯)
        
        ```c
        /* exception.h 파일
           
           Page fault handler.  
           이 뼈대는 가상화 구현하는데 구현되어야 하는 영역이다.
           Project2에서 또한 이 코드 수정이 요구된다.
        
           들어가기에 앞서, CR2(Control Register 2)와 fault에 대한 정보는 
           exception.h에 PF_* 코드의 멤버를 확인하면 된다.*/
        static void
        page_fault (struct intr_frame *f) {
        	bool not_present;  /* True: not-present page, false: writing r/o page. */
        	bool write;        /* True: access was write, false: access was read. */
        	bool user;         /* True: access by user, false: access by kernel. */
        	void *fault_addr;  /* Fault address. */
        
        	/* Obtain faulting address, the virtual address that was
        	   accessed to cause the fault.  It may point to code or to
        	   data.  It is not necessarily the address of the instruction
        	   that caused the fault (that's f->rip). */
        
        	fault_addr = (void *) rcr2();
        
        	/* Turn interrupts back on (they were only off so that we could
        	   be assured of reading CR2 before it changed). */
        	intr_enable ();
        
        	/* exception.h의 PF_*과 매핑 */
        	not_present = (f->error_code & PF_P) == 0;
        	write = (f->error_code & PF_W) != 0;
        	user = (f->error_code & PF_U) != 0;
        
        #ifdef VM
        	/* For project 3 and later. */
        	if (vm_try_handle_fault (f, fault_addr, user, write, not_present))
        		return;
        #endif
        
        	/* Count page faults. */
        	page_fault_cnt++;
        
        	/* If the fault is true fault, show info and exit. */
        	printf ("Page fault at %p: %s error %s page in %s context.\n",
        			fault_addr,
        			not_present ? "not present" : "rights violation",
        			write ? "writing" : "reading",
        			user ? "user" : "kernel");
        	kill (f);
        }
        
        /* exception.h 파일
           Page fault error code bits that describe the cause of the exception.  */
        #define PF_P 0x1    /* 0: not-present page. 1: access rights violation. */
        #define PF_W 0x2    /* 0: read, 1: write. */
        #define PF_U 0x4    /* 0: kernel, 1: user process. */
        ```
        
        어떤 경우든 리소스가 '누수'되지 않도록 주의해야 합니다. 예를 들어, 시스템 호출이  잠금을 획득(acquired lock)하거나 malloc()을 통해 메모리를 할당했다고 가정해 보겠습니다. **나중에 잘못된 사용자 포인터가 발생하더라도 반드시 잠금을 해제하거나 메모리 페이지를 해제**해야 합니다. 사용자 포인터를 역참조하기 전에 확인하도록 선택했다면 이 과정은 간단합니다. 잘못된 포인터로 인해 페이지 오류가 발생하는 경우 메모리 액세스에서 오류 코드를 반환할 방법이 없기 때문에 처리하기가 더 어렵습니다. 따라서 후자의 기법을 시도해보고 싶은 분들을 위해 약간의 유용한 코드를 제공해드리겠습니다:
        
        ```c
        /* Reads a byte at user virtual address UADDR.
         * UADDR must be below KERN_BASE.
         * Returns the byte value if successful, -1 if a segfault
         * occurred. */
        static int64_t
        get_user (const uint8_t *uaddr) {
            int64_t result;
            __asm __volatile (
            "movabsq $done_get, %0\n"
            "movzbq %1, %0\n"
            "done_get:\n"
            : "=&a" (result) : "m" (*uaddr));
            return result;
        }
        
        /* Writes BYTE to user address UDST. 
         * UDST must be below KERN_BASE.
         * Returns true if successful, false if a segfault occurred. */
        static bool
        put_user (uint8_t *udst, uint8_t byte) {
            int64_t error_code;
            __asm __volatile (
            "movabsq $done_put, %0\n"
            "movb %b2, %1\n"
            "done_put:\n"
            : "=&a" (error_code), "=m" (*udst) : "q" (byte));
            return error_code != -1;
        }
        ```
        
        이러한 각 함수는 사용자 주소가 이미 `KERN_BASE` 아래에 있는 것으로 확인되었다고 가정합니다. 또한 커널에서 페이지 오류가 발생하면 rax를 -1로 설정하고 이전 값을 %rip에 복사하도록 `page_fault()`를 수정했다고 가정합니다.
        
- Argument Passing
    
    `process_exec()`에서 사용자 프로그램에 대한 인수를 설정합니다.
    
    - ****x86-64 Calling Convention****
        
        이 섹션에서는 64비트 x86-64 구현의 Unix에서 일반 함수 호출에 사용되는 **규칙**의 중요한 사항을 요약합니다. 간결성을 위해 일부 세부 사항은 생략했습니다. 자세한 내용은 [System V AMD64 ABI](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI)를 참조하십시오.
        
        호출 규칙은 다음과 같이 작동합니다:
        
        1. 사용자 수준 애플리케이션은 `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8` 및 `%r9` 시퀀스를 전달하기 위해 정수 레지스터로 사용합니다.
        2. 호출자는 스택에 다음 명령어의 주소(반환 주소)를 밀어넣고 호출자의 첫 번째 명령어로 점프합니다. 단일 x86-64 명령어인 `CALL`은 이 두 가지(push and jump)를 모두 수행합니다.
        3. 호출자가 실행합니다.
        4. 수신자가 반환값을 가지고 있으면 레지스터 RAX에 저장합니다.
        5. 호출자는 반환 주소를 스택에서 꺼내고 x86-64 `RET` 명령어를 사용하여 지정된 위치로 점프하여 반환합니다.
        
        세 개의 int 인수를 받는 함수 `f()`를 생각해 봅시다. 이 다이어그램은 f()가 f(1, 2, 3)으로 호출된다고 가정했을 때 위 3단계의 시작 부분에서 호출자가 볼 수 있는 샘플 스택 프레임과 레지스터 상태를 보여줍니다. 초기 스택 주소는 임의입니다:
        
        ```c
         				               	     +----------------+
        stack pointer --> 0x4747fe70 | return address |
                                     +----------------+
        RDI: 0x0000000000000001 | RSI: 0x0000000000000002 | RDX: 0x0000000000000003
        ```
        
    - 🌟****Program Startup Details(p230)****
        
        사용자 프로그램용 핀토스 C 라이브러리는 `lib/user/entry.c`에 지정된 `_start()`를 사용자 프로그램의 진입점으로 지정합니다. 이 함수는 `main()`을 감싸는 래퍼로, `main()`이 반환되면 `exit()`를 호출합니다:
        
        ```c
        void
        _start (int argc, char *argv[]) {
        exit (main (argc, argv));
        }
        ```
        
        커널은 사용자 프로그램이 실행을 시작하기 전에 **초기 함수에 대한 인수를 레지스터에 넣어야** 합니다. 인수는 일반적인 호출 규칙과 동일한 방식으로 전달됩니다.
        
        다음 예제 명령의 인수를 처리하는 방법을 살펴보겠습니다: `/bin/ls -l foo bar`
        
        1. 명령을 단어로 나눕니다: `/bin/ls`, `-l` , `foo` , `bar`
        2. 단어를 스택의 맨 위에 배치합니다. 포인터를 통해 참조되므로 순서는 중요하지 않습니다.
        3. 각 문자열의 주소와 널 포인터 경계(\0)의 주소를 오른쪽에서 왼쪽 순서로 스택에 밀어 넣습니다. 이것이 argv의 요소입니다. 널 포인터 경계는 C 표준에서 요구하는 대로 `argv[argc]`가 널 포인터인지 확인합니다. 이 순서는 `argv[0]`이 가장 낮은 가상 주소에 있는 것을 보장(ensure)합니다. word정렬(word-aligned) 액세스는 정렬되지 않은 액세스보다 빠르므로 최상의 성능을 위해 **첫 번째 푸시 전에 스택 포인터를 8의 배수로 반올림**하세요.
            
            → argv[4] = ‘/0’
            
        4. `%rsi`를 `argv`(`argv[0]`의 주소)로 가리키고 `%rdi`를 `argc`로 설정합니다.
        5. **마지막으로 가짜 "반환 주소"를 푸시합니다. 입력 함수는 절대 반환되지 않지만 스택 프레임은 다른 함수와 동일한 구조를 가져야 합니다.**
        
        아래 표는 사용자 프로그램이 시작되기 직전의 스택 상태와 관련 레지스터를 보여줍니다. 스택이 아래로 내려가는 것을 볼 수 있습니다.
        
        주소 이름 데이터 유형
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b278eae5-15fb-42de-a493-229718a0b327/c17dd03f-310b-4df0-b0a3-d068a23f86b6/Untitled.png)
        
        RDI: 4 | RSI: 0x4747ffc0
        
        이 예제에서는 스택 포인터가 `0x4747ffb8`로 초기화됩니다. 위와 같이 코드가 `include/threads/vaddr.h`에 정의된 `USER_STACK`에서 스택을 시작해야 합니다.
        
        인자 전달 코드를 디버깅할 때 `<stdio.h>`에 선언된 비표준 `hex_dump()`함수가 유용할 수 있습니다.
        
    - ****Implement the argument passing.****
        
        현재 `process_exec()`은 새 프로세스에 인수를 전달하는 기능을 지원하지 않습니다. 이 기능을 구현하려면 `process_exec()`을 확장하여 프로그램 파일 이름을 단순히 인자로 받는 대신 공백으로 단어로 나누도록 하세요. 첫 번째 단어는 프로그램 이름, 두 번째 단어는 첫 번째 인수가 되는 식으로 말이죠. 즉, process_exec("grep foo bar")는 두 개의 인자 foo와 bar를 전달하여 grep을 실행해야 합니다.
        
        명령줄 내에서 여러 개의 공백은 하나의 공백에 해당하므로 process_exec("grep foo bar")는 원래 예제와 동일합니다. 명령줄 인수의 길이에 합리적인 제한을 둘 수 있습니다. 예를 들어 인수를 한 페이지(4KB)에 들어갈 수 있는 길이로 제한할 수 있습니다. (핀토스 유틸리티가 커널에 전달할 수 있는 명령줄 인수는 128바이트로 제한되어 있습니다).
        
        인자 문자열은 **원하는 방식으로 파싱**할 수 있습니다. 길을 잃었다면 `include/lib/string.h`에 프로토타입이 있고 `lib/string.c`에 철저한 주석으로 구현된 `strtok_r()`을 참조하세요. 자세한 내용은 man 페이지(프롬프트에서 `man strtok_r` 실행을 통해 )에서 확인할 수 있습니다.
        
- User Memory
    - **Implement user memory access**
        
        **시스템 콜을 구현**하려면 **사용자 가상 주소 공간에서 데이터를 읽고 쓸 수 있는 방법을 제공**해야 합니다. 인수를 받을 때는 이 기능이 필요하지 않습니다. 그러나 시스템 콜의 인수로 제공된 포인터에서 데이터를 읽을 때는 이 기능을 통해 프록시해야 합니다. 사용자가 잘못된 포인터를 제공하거나 커널 메모리에 대한 포인터를 제공하거나 해당 영역 중 하나에 부분적으로 블록을 제공하면 어떻게 될까요? 이러한 경우 사용자 프로세스를 종료하여 처리해야 합니다.
        
- System Calls
    - system call infrastructure 구현.
        
        `userprog/syscall.c`에서 시스템 호출 **핸들러**를 구현합니다. 우리가 제공하는 스켈레톤 구현은 프로세스를 종료하여 시스템 호출을 "handles"합니다. 시스템 호출 번호를 검색한 다음 **시스템 호출 인수**를 검색하고 적절한 작업을 수행해야 합니다.
        
    - ****System Call Details****
        
        첫 번째 프로젝트에서는 이미 운영 체제가 사용자 프로그램으로부터 제어권을 되찾을 수 있는 한 가지 방법, 즉 타이머와 입출력 장치의 인터럽트를 다루었습니다. 이러한 인터럽트는 **CPU 외부의 엔티티**에 의해 발생하므로 "**외부" 인터럽트**라고 합니다.
        
        운영 체제는 프로그램 코드에서 발생하는 이벤트인 **소프트웨어 예외**도 처리합니다. 이러한 예외는 페이지 오류나 0으로 나누기 같은 오류일 수 있습니다. 예외는 사용자 프로그램이 운영 체제에 서비스("시스템 호출")를 요청할 수 있는 수단이기도 합니다.
        
        기존 x86 아키텍처에서는 시스템 호출이 다른 소프트웨어 예외와 동일하게 처리되었습니다. 그러나 x86-64에서는 제조업체가 시스템 호출을 위한 특수 명령어인 `syscall`을 도입했습니다. 이를 통해 시스템 호출 핸들러를 빠르게 호출할 수 있습니다.
        
        오늘날 `**syscall`명령은 x86-64에서 시스템 호출을 호출하는 데 가장 일반적으로 사용되는 수단**입니다. 핀토스에서 사용자 프로그램은 시스템 호출을 위해 `syscall`을 호출합니다. 시스템 호출 번호와 추가 인수는 두 가지 사항을 제외하고는 시스템 호출 명령을 호출하기 전에 일반적인 방식으로 레지스터에 설정되어야 합니다: (p173)
        
        - `%rax`는 시스템 콜 번호입니다.
        - **네 번째** 인수는 `%rcx`가 아니라 `%r10`입니다.
        
        따라서 시스템 콜 핸들러 `syscall_handler()`가 제어권을 가져올 때 시스템 호출 번호는 **rax**에 있고 인수는 `%rdi`, `%rsi`, `%rdx`, `%r10`, `%r8`, `%r9`의 순서로 전달됩니다. 
        
        → 원래는 `%rdi`, `%rsi`, `%rdx`, `**%rcx**`, `%r8` ,`%r9` 순이였음
        
        호출자의 레지스터는 전달된 `struct intr_frame`에 액세스할 수 있습니다. (`struct intr_frame`은 **커널 스택**에 있습니다).
        
        함수 반환 값에 대한 x86-64 규칙은 **RAX 레지스터에 값을 배치**하는 것입니다. 값을 반환하는 시스템 호출은 `struct intr_frame`의 `rax` 멤버를 수정하여 값을 반환할 수 있습니다.
        
    - ****Implement the following system calls.****
        
        나열된 프로토타입은 `include/lib/user/syscall.h`를 포함하는 사용자 프로그램에서 볼 수 있는 것입니다(이 헤더와 포함 `/lib/user`의 다른 모든 헤더는 사용자 프로그램에서만 사용할 수 있습니다). 각 시스템 호출에 대한 **시스템 호출 번호**는 `include/lib/syscall-nr.h`에 정의되어 있습니다:
        
        ```c
        void halt (void);
        ```
        
        > `power_off()`(`src/include/threads/init.h`에 선언됨)를 호출하여 핀토스를 종료합니다. 이 함수는 deadlock 상태 등에 대한 일부 정보를 잃게 되므로 **거의 사용하지 않는 것이 좋습니다**.
        > 
        
        ```c
        void exit (int status);
        ```
        
        > 현재 사용자 프로그램을 종료하고, `status`를 커널로 반환합니다. 프로세스의 부모가 `wait`경우(아래 참조), 부모는 이 상태를 반환받습니다. 일반적으로 `status` `0`은 성공을 나타내고 `0`이 아닌 값은 오류를 나타냅니다.
        > 
        
        ```c
        pid_t fork (const char *thread_name);
        ```
        
        > 현재 프로세스의 복제본인 새 프로세스를 THREAD_NAME이라는 이름으로 만듭니다. 호출자가 저장한 레지스터인 `%RBX`, `%RSP`, `%RBP`, `%R12` - `%R15`를 제외한 레지스터의 값은 복제할 필요가 없습니다. 자식 프로세스의 pid를 반환해야 하며, 그렇지 않으면 유효한 pid가 아니어야 합니다. 자식 프로세스에서 반환 값은 `0`이어야 합니다. 자식 프로세스는 **file descriptor 및 가상 메모리 공간을 포함한 중복 리소스**를 가져야 합니다. 부모 프로세스는 자식 프로세스가 성공적으로 복제되었는지 여부를 알기 전까지는 포크에서 반환하지 않아야 합니다. 즉, 자식 프로세스가 리소스를 복제하는 데 실패하면 부모의 fork() 호출은 TID_ERROR를 반환해야 합니다.
        > 
        
        > 템플릿은 `threads/mmu.c`의 `pml4_for_each()`를 사용하여 해당 페이지 테이블 구조를 포함한 전체 사용자 메모리 공간을 복사하지만, 그러나 당신은 전달된 `pte_for_each_func`의 누락된 부분을 채워야 합니다(가상 주소 참조).
        > 
        
        ```c
        int exec (const char *cmd_line);
        ```
        
        > 주어진 인자를 전달하여 현재 프로세스를 `cmd_line`에 이름이 지정된 실행 파일로 변경합니다. 성공하면 절대 반환되지 않습니다. 그렇지 않으면 어떤 이유로든 프로그램을 로드하거나 실행할 수 없는 경우 종료 상태 `-1`로 프로세스가 종료됩니다. 이 함수는 `exec`를 호출한 스레드의 이름을 변경하지 않습니다. **file descriptor는 `exec` 호출 내내 열려 있다**는 점에 유의하세요.
        > 
        
        ```c
        int wait (pid_t pid);
        ```
        
        > 자식 프로세스 `pid`를 기다렸다가 자식의 종료 상태를 되찾습니다(retrieves). `pid`가 아직 살아있다면 종료될 때까지 기다립니다. 그런 다음 `pid`가 종료하기 위해 전달한 상태를 반환합니다. `pid`가 `exit()`를 호출하지 않았지만 커널에 의해 종료된 경우(예: 예외로 인해 종료된 경우), `wait(pid)`는 `-1`을 반환해야 합니다. 부모 프로세스가 wait를 호출할 때 이미 종료된 자식 프로세스를 기다리는 것은 완전히 합법적이지만, 커널은 여전히 부모가 자식의 종료 상태를 되찾거나 자식이 커널에 의해 종료되었다는 사실을 알 수 있도록 허용해야 합니다.
        > 
        
        > `wait`는 다음 조건 중 하나라도 참이면 실패하고 즉시 `-1`을 반환해야 합니다:
        > 
        > 
        > (-1) 반환 case
        > 
        
        1)
        
         `pid`가 호출 프로세스의 직접 자식(direct child)을 참조하지 않는 경우 (-1)을 반환함. 호출 프로세스가 `fork`에 대한 성공적인 호출에서 반환 값으로 `pid`를 받은 경우에만 `pid`가 호출 프로세스의 직접 자식이다. 자식은 상속되지 않는다는 걸 인지해라. A가 자식 B를 생성하고 B가 자식 프로세스 C를 생성하는 경우, A는 C를 기다릴 수 없습니다. 심지어 B가 죽더라도. 프로세스 A의 `wait(C)` 호출은 실패해야 합니다. 마찬가지로, 고아 프로세스는 부모 프로세스가 먼저 종료되면 새 부모에게 할당되지 않습니다.
        
        2)
        
        `wait`를 호출하는 프로세스가 이미 `pid`에서 `wait`를 호출한 경우 참을 반환함. 즉, **한 프로세스는 최대 한 번만 특정 자식을 `wait`할 수 있습니다**.
        
        ---
        
        프로세스는 자식을 얼마든지 생성할 수 있고, 어떤 순서로든 자식을 `wait`할 수 있으며, **심지어 자식 중 일부 또는 전부를 기다리지 않고 종료할 수도** 있습니다. 설계는 **대기가 발생할 수 있는 모든 방법을 고려**해야 합니다. `struct thread`를 포함한 **프로세스의 모든 리소스**는 부모가 기다리는지 여부와 관계없이, 그리고 자식이 부모보다 먼저 종료하든 나중에 종료하든 관계없이 **해제**되어야 합니다.
        
        **초기 프로세스가 종료될 때까지 핀토스가 종료되지 않도록 보장해야 합니다.** 제공된 핀토스 코드는 `main()`(`threads/init.c`)에서 `process_wait()`(`userprog/process.c`)를 호출하여 이 작업을 시도합니다. 함수 상단의 주석에 따라 `process_wait()`을 구현한 다음 `process_wait()`의 관점에서 대기 시스템 호출을 구현하는 것이 좋습니다.
        
        이 시스템 호출을 구현하려면 다른 어떤 것보다 훨씬 더 많은 작업이 필요합니다.
        
        ```c
        bool create (const char *file, unsigned initial_size);
        ```
        
        > 초기 `initial_size` 바이트 크기의 `file`이라는 새 파일을 만듭니다. 성공하면 true을, 그렇지 않으면 false을 반환합니다. **새 파일을 만든다고 해서 파일이 열리지는 않습니다**. 새 파일을 열려면 `open`시스템 호출이 필요한 별도의 작업입니다.
        > 
        
        ```c
        bool remove (const char *file);
        ```
        
        > `file`이라는 파일을 삭제합니다. 성공하면 true을, 그렇지 않으면 false을 반환합니다. 파일은 열려 있는지 닫혀 있는지에 관계없이 제거할 수 있으며 열려 있는 파일을 제거해도 닫히지 않습니다. 자세한 내용은 FAQ에서 열린 파일 제거하기를 참조하세요.
        > 
        
        ```c
        int open (const char *file);
        ```
        
        > `file`이라는 파일을 엽니다. "file descriptor"(fd)라는 음수가 아닌 정수 handle을 반환하거나, 파일을 열 수 없으면 `-1`을 반환합니다. 번호가 0과 1인 file descriptor는 콘솔용으로 예약되어 있습니다. fd 0(`STDIN_FILENO`)은 표준 입력이고, fd 1(`STDOUT_FILENO`)은 표준 출력입니다. `open` 시스템 호출은 이러한 file descriptor 중 어느 것도 반환하지 않으며(0,1중에 반환 안함), 아래에 명시적(explicitly)으로 설명된 경우에만 시스템 호출 인수로 유효합니다. **각 프로세스에는 독립적인 file descriptor 집합이 있습니다**. file descriptor 는 자식 프로세스에 의해 상속됩니다. 단일 프로세스에서든 다른 프로세스에서든 단일 파일을 두 번 이상 열면 열 때마다 새 file descriptor가 반환됩니다. 단일 파일에 대한 서로 다른 file descriptor는 별도의 닫기 호출을 통해 독립적으로 닫히며 **파일 위치(file position;읽은 위치)를 공유하지 않습니다**. ***extra*를** 수행하려면 0부터 시작하는 정수를 반환하는 Linux 스키마를 따라야 합니다.
        > 
        
        ```c
        int filesize (int fd);
        ```
        
        > `fd`로 열린 파일의 크기를 바이트 단위로 반환합니다.
        > 
        
        ```c
        int read (int fd, void *buffer, unsigned size);
        ```
        
        > `fd`로 열린 파일에서 `buffer`로 `size` 바이트를 읽습니다. 실제로 읽은 바이트 수(end of file에서 `0`) 또는 파일을 읽을 수 없는 경우(end of file 이외의 조건으로 인해) `-1`을 반환합니다. `fd` 0(표준입력)은 `input_getc()`를 사용하여 키보드에서 읽습니다.
        > 
        
        → end of file; EOF; 파일의 끝
        
        ```c
        int write (int fd, const void *buffer, unsigned size);
        ```
        
        > `buffer`에서 열린 파일 `fd`에 `size` 바이트를 씁니다. 실제로 쓰여진 바이트 수를 반환하며, 일부 바이트가 쓰여지지 않으면 `size`보다 작을 수 있습니다. 파일 끝을 지나서 쓰면 일반적으로 파일이 확장되지만 기본 파일 시스템에서는 파일 확장이 구현되지 않습니다. 예상되는 동작은 파일 끝 부분까지 가능한 한 많은 바이트를 쓰고 실제 쓰여진 수를 반환하거나, 바이트를 전혀 쓸 수 없는 경우 `0`을 반환하는 것입니다. `fd` 1(표준출력)은 콘솔에 씁니다. 콘솔에 쓰는 코드는 적어도 크기가 수백 바이트보다 크지 않다면 `putbuf()` 호출 한 번으로 모든 버퍼를 써야 합니다(큰 버퍼는 분할하는 것이 합리적입니다). 그렇지 않으면 서로 다른 프로세스에서 출력된 텍스트 줄이 콘솔에서 interleaved(백지를 끼워 넣다?)되어 사람이 읽는 사람과 채점 스크립트 모두를 혼란스럽게 만들 수 있습니다.
        > 
        
        ```c
        void seek(int fd, unsigned position);
        ```
        
        > 열린 파일 `fd`에서 읽거나 쓸 다음 바이트를 파일 시작부터 바이트 단위로 표현되는 `position`로 변경합니다(따라서 `position`이 `0`이면 파일의 시작입니다). 최근 EOF를 지나서 찾는 것은 오류가 아닙니다. 나중  `read` 는 EOF을 나타내는 0바이트를 얻습니다. 나중  `write`는 파일을 확장하여 기록되지 않은 간격을 0으로 채웁니다. (**단, 핀토스에서는 프로젝트 4가 완료될 때까지 파일 길이가 고정되어 있으므로 파일 끝을 지나서 쓰면 오류가 반환됩니다**). 이러한 의미(sementics)는 파일 시스템에서 구현되며 시스템 호출 구현에 특별한 노력이 필요하지 않습니다.
        > 
        
        ```c
        unsigned tell (int fd);
        ```
        
        > 열린 파일 `fd`에서 읽거나 쓸 다음 바이트의 위치를 파일 시작부터 바이트로 표현하여 반환합니다.
        > 
        
        ```c
        void close (int fd);
        ```
        
        > file descriptor인  `fd`를 닫습니다. 프로세스를 종료(Exit)하거나 강제종료(Terminate)하면, 마치 이 함수를 각각에 대해 호출하는 것처럼, 열려 있는 모든 file descriptor를 암시적(implicit)으로 닫습니다.
        > 
        
        이 파일은 다른 시스템 호출을 정의합니다. 지금은 무시하세요. 프로젝트 3에서 일부는 구현하고 나머지는 프로젝트 4에서 구현할 예정이므로 확장성을 염두에 두고 시스템을 설계해야 합니다.
        
        여러 사용자 프로세스가 한 번에 호출할 수 있도록 시스템 호출을 **동기화**해야 합니다. 특히 여러 스레드에서 한 번에 `filesys` 디렉터리에 제공된 파일 시스템 코드를 호출하는 것은 안전하지 않습니다. 시스템 호출 구현은 파일 시스템 코드를 중요한 섹션(critical section)으로 취급해야 합니다. `process_exec()`도 파일에 액세스한다는 사실을 잊지 마세요. 현재로서는 `filesys` 디렉터리의 코드를 수정하지 않는 것이 좋습니다.
        
        사용자 프로세스가 C 프로그램에서 각 시스템 호출을 호출할 수 있는 방법을 제공하기 위해 `lib/user/syscall.c`에 각 시스템 호출에 대한 사용자 수준 함수를 제공했습니다. 각 함수는 약간의 인라인 어셈블리 코드를 사용하여 시스템 호출을 호출하고 (적절한 경우) 시스템 호출의 반환값을 반환합니다.
        
        이 부분이 끝나면, 그리고 앞으로도 핀토스는 **방탄**(bulletproof;not BTS)이 될 것입니다. 사용자 프로그램이 할 수 있는 어떤 작업도 OS의 충돌, 패닉, assertion 실패 또는 기타 오작동을 유발해서는 안 됩니다. 이 점을 강조하는 것이 중요합니다. **테스트는 여러 가지 방법으로 시스템 호출을 중단하려고 시도할 것**입니다. **모든 코너 케이스를 생각하고 처리**해야 합니다. 사용자 프로그램이 OS를 중단시킬 수 있는 유일한 방법은 halt 시스템 콜을 호출하는 것입니다.
        
        시스템 호출에 잘못된 인수가 전달된 경우 허용되는 옵션에는 오류 값 반환(값을 반환하는 호출의 경우), 정의되지 않은 값 반환 또는 프로세스 종료가 포함됩니다.
        
- Process Termination Messages
    
    **Print out the process termination message**
    
    사용자 프로세스가 `exit`를 호출하거나 다른 이유로 인해 강제종료될 때마다 프로세스의 이름과 종료 코드를 다음과 같은 형식으로 인쇄합니다.
    
    ```c
    printf ("%s: exit(%d)\n", ...);
    ```
    
    인쇄되는 이름은 `fork()`에 전달된 전체 이름이어야 합니다. 사용자 프로세스가 아닌 커널 스레드가 종료되거나 중지(halt) 시스템 콜이 호출될 때는 이러한 메시지를 인쇄하지 마십시오. 프로세스를 로드하지 못했을 때 이 메시지는 **선택 사항**입니다.
    
    이 메시지 외에 제공된 핀토스가 아직 인쇄하지 않는 다른 메시지는 인쇄하지 마세요. 디버깅 중에 추가 메시지가 유용할 수 있지만 채점 스크립트를 혼동하여 점수가 낮아질 수 있습니다.
    
- Denying Writes to Executables
    
    실행 파일에 대한 쓰기 거부.
    
    실행 파일로 사용 중인 파일에 대한 쓰기를 거부하는 코드를 추가하세요. 프로세스가 디스크에서 변경 중인 코드를 실행하려고 할 때 예상치 못한 결과가 발생할 수 있기 때문에 많은 OS에서 이 기능을 사용합니다. 이는 프로젝트 3에서 가상 메모리가 구현되면 특히 중요해지지만, 지금 당장 실행해도 나쁠 것은 없습니다.
    
    열린 파일에 대한 쓰기를 방지하기 위해 `file_deny_write()`를 사용할 수 있습니다. 파일에 대해 `file_allow_write()`를 호출하면 다시 활성화됩니다(다른 opener에서 파일 쓰기를 거부하지 않는 한). 파일을 **닫아도** 쓰기가 다시 활성화됩니다. 따라서 프로세스의 실행 파일에 대한 쓰기를 거부하려면/  프로세스가 계속 실행되고 있는 동안에는  파일을 열어 두어야 합니다.(실행중인 프로세스 파일을 열어놓으라는 뜻인 듯)
    
- Extend File Descriptor (Extra)
    
    핀토스가 Linux에서 stdin, stdout 및 dup2 시스템 호출 종료를 지원하도록 만드세요.
    
    현재 핀토스의 구현에서는 stdin과 stdout의 fd를 **닫는 것이 금지**되어 있습니다. 이 추가 점수 요구 사항에서는 먼저 사용자가 리눅스와 동일하게 stdin과 stdout을 닫을 수 있도록 허용합니다. 즉, 사용자가 stdin을 닫으면 프로세스가 입력을 읽지 않아야 하고, stdout을 닫으면 프로세스가 아무것도 출력하지 않아야 합니다.
    
    다음으로 dup2 시스템 호출을 구현합니다.
    
    ```c
    int dup2(int oldfd, int newfd);
    ```
    
    > `dup2()` 시스템 호출은 `newfd`에 지정된 file descriptor 번호로 file descriptor `oldfd`의 **복사본을 생성**하고 성공하면 `newfd`를 반환합니다. file descriptor `newfd`가 이전에 열려 있었다면 재사용되기 전에 자동으로 닫힙니다.
    > 
    
    > 다음 사항에 유의하세요:
    > 
    > - `oldfd`가 유효한 file descriptor가 아닌 경우 호출이 실패하고(`-1`을 반환) `newfd`가 닫히지 않습니다.
    > - `oldfd`가 유효한 file descriptor이고 `newfd`의 값이 `oldfd`와 같으면 `dup2()`는 아무 작업도 수행하지 않고 `newfd`를 반환합니다.
    
    > 이 시스템 호출에서 성공적으로 반환된 후에는 이전 file descriptor와 새 file descriptor를 서로 바꿔서 사용할 수 있습니다. 서로 다른 file descriptor이지만 **동일한 open file description을 참조하므로 파일 오프셋과 상태 플래그를 공유**합니다. 예를 들어, descriptor 중 하나에서 `seek`를 사용하여 파일 오프셋이 수정되면 다른 파일에 대해서도 오프셋이 변경됩니다.
    > 
    
    `dup`된 file descriptor는 포크 후에도 그 의미를 유지해야 합니다.
    
    **크레딧을 받으려면 모든 테스트 케이스를 통과해야 합니다. 전부 아니면 전무.(Take all or Nothing)**
    
- FAQ
    - 얼마나 많은 코드를 작성해야 하나요?
        
        다음은 git diff --stat로 생성한 참조 솔루션의 요약입니다. 마지막 행에는 삽입 및 삭제된 총 줄이 표시되며, 변경된 줄은 삽입과 삭제 모두로 계산됩니다. 참조 솔루션은 가능한 솔루션 중 하나에 불과합니다. 다른 많은 솔루션도 가능하며, 그 중 많은 솔루션이 참조 솔루션과 크게 다릅니다. 일부 우수한 솔루션은 참조 솔루션에서 수정한 모든 파일을 수정하지 않을 수도 있고, 일부 솔루션은 참조 솔루션에서 수정하지 않은 파일을 수정할 수도 있습니다. 또한 여기에는 추가 요구 사항의 구현도 포함됩니다. 참고로, 약 150개 라인이 추가 요구 사항과 관련이 있습니다.
        
        ```c
        src/include/threads/thread.h   |  23 ++
        src/include/userprog/syscall.h |   3 +
        src/threads/thread.c           |   5 +
        src/userprog/exception.c       |   4 +
        src/userprog/process.c         | 355 +++++++++++++++++++++++++++++++++++++++++-
        src/userprog/syscall.c         | 429 ++++++++++++++++++++++++++++++++++++++++++-
        6 files changed, 782 insertions(+), 37 deletions(-)
        ```
        
    - 핀토스 -p 파일 -- -q를 실행하면 커널이 항상 패닉 상태에 빠집니다.
        - 파일 시스템을 포맷하셨나요(`pintos -f`로)?
        - 파일 이름이 너무 기나요?
            - 파일 시스템은 파일 이름을 14자로 제한합니다.
                
                pintos -p ../../examples/echo -- -q와 같은 명령은 이 제한을 초과합니다.
                
                대신 pintos -p ../../examples/echo:echo -- -q를 사용하여 파일을 echo라는 이름으로 지정하세요.
                
                (14글자 초과하면 → 새로운 파일명만들기)
                
        - 파일 시스템이 꽉 찼나요?
        - 파일 시스템에 이미 16개의 파일이 포함되어 있나요? 기본 Pintos 파일 시스템에는 16개 파일 제한이 있습니다.
        - 파일 시스템이 너무 조각화되어 파일을 위한 연속 공간이 충분하지 않을 수 있습니다.
    - pintos -p ../file --을 실행하면 '파일'이 복사되지 않습니다.
        
        파일은 기본적으로 참조하는 이름으로 작성되므로 이 경우 복사된 파일의 이름은 '../file'이 됩니다. 대신 `pintos -p ../file:file --`을 실행하는 것이 좋습니다.
        
    - 내 모든 사용자 프로그램이 페이지 오류(page fault)와 함께 죽습니다.
        
        이는 인수 전달을 구현하지 않았거나 올바르게 구현하지 않은 경우에 발생합니다. 사용자 프로그램을 위한 기본 C 라이브러리는 스택에서 argv를 읽으려고 합니다. 스택이나 레지스터가 제대로 설정되지 않은 경우 페이지 오류(page fault)가 발생합니다.
        
    - 내 모든 사용자 프로그램이 `system call`과 함께 죽어요!
        
        다른 것을 보기 전에 시스템 호출을 구현해야 합니다. 모든 정상적인 프로그램은 적어도 한 번 이상의 시스템 호출(`exit()`)을 시도하며, 대부분의 프로그램은 그 이상의 시스템 호출을 시도합니다. 특히 `printf()`는 쓰기 시스템 호출을 호출합니다. 기본 시스템 호출 핸들러는 그냥 `system call` 을 출력하고 프로그램을 종료합니다! 그때까지는 `hex_dump()`를 사용하여 인수 전달이 올바르게 구현되었는지 확인할 수 있습니다.
        
    - 사용자 프로그램을 디스어셈블하려면 어떻게 해야 하나요?
        
        objdump 유틸리티는 전체 사용자 프로그램이나 객체 파일을 디스어셈블할 수 있습니다. objdump -d 파일로 호출하세요. GDB의 `disassemble` 명령을 사용하여 개별 함수를 분해할 수 있습니다.
        
    - 왜 많은 C 포함 파일이 핀토스 프로그램에서 작동하지 않나요?  + 내 Pintos 프로그램에서 lib foo를 사용할 수 있나요?
        
        저희가 제공하는 C 라이브러리는 매우 제한적입니다. 실제 운영 체제의 C 라이브러리에서 기대할 수 있는 많은 기능이 포함되어 있지 않습니다. C 라이브러리는 I/O 및 메모리 할당을 위한 시스템 호출을 수행해야 하므로 운영 체제(및 아키텍처)에 맞게 특별히 구축해야 합니다. (물론 모든 함수가 그렇지는 않지만 일반적으로 라이브러리는 하나의 단위로 컴파일됩니다.)
        
        원하는 라이브러리가 핀토스가 구현하지 않은 C 라이브러리의 일부를 사용할 가능성이 높습니다. Pintos에서 작동하도록 하려면 적어도 약간의 포팅 작업이 필요할 것입니다. 특히 핀토스 사용자 프로그램 C 라이브러리에는 `malloc()` 구현이 없습니다.
        
    - 새 사용자 프로그램을 컴파일하려면 어떻게 해야 하나요?
        
        `src/examples/Makefile`을 수정한 다음 `make`를 실행합니다.
        
    - 디버거에서 사용자 프로그램을 실행할 수 있나요?
        
        예, 몇 가지 제한이 있습니다. GDB를 참조하세요.
        
    - tid_t와 pid_t의 차이점은 무엇인가요?
        
        tid_t는 **커널 스레드**를 식별하며, 이 스레드에는 사용자 프로세스가 실행 중이거나(`process_fork()`로 생성한 경우) 실행 중이 아닐 수도 있습니다(`thread_create()`로 생성한 경우). 커널에서만 사용되는 데이터 유형입니다. pid_t는 사용자 프로세스를 식별합니다. 사용자 프로세스와 커널이 실행 및 대기 시스템 호출에서 사용합니다. tid_t와 pid_t에 적합한 유형을 선택할 수 있습니다. 기본적으로 둘 다 int입니다. 둘 다 동일한 값이 동일한 프로세스를 식별하도록 일대일 매핑으로 만들거나 더 복잡한 매핑을 사용할 수 있습니다. 여러분에게 달려 있습니다.
        
    - `struct file *`을 캐스팅하여 file descriptor를 가져올 수 있나요? +  `struct thread *`를 `pid_t`로 그냥 형변환해도 되나요?
        
        아니요. `pid_t`와 `file descriptor`는 포인터 유형보다 작으므로 직접 형변환을 할 수 있습니다.
        
    - 프로세스당 최대 열린 파일 수를 설정할 수 있나요?
        
        임의의 제한을 설정하지 않는 것이 좋습니다. 필요한 경우 프로세스당 128개의 열린 파일로 제한할 수 있습니다. 그러나 추가 요구 사항(extra)을 구현하려는 경우에는 제한이 없어야 합니다.
        
    - 열려 있는 파일이 제거되면 어떻게 되나요?
        
        파일에 대한 표준 유닉스 시맨틱을 구현해야 합니다. 즉, 파일이 제거되면 해당 파일에 대한 file descriptor가 있는 모든 프로세스는 해당 descriptor를 계속 사용할 수 있습니다. 즉, 해당 프로세스는 파일을 읽고 쓸 수 있습니다. 파일에는 이름이 없어지고 다른 프로세스는 파일을 열 수 없지만 파일을 참조하는 모든 file descriptor가 닫히거나 컴퓨터가 종료될 때까지 파일은 계속 존재합니다. 
        
        Q. 삭제 된 다음 새로 쓰면 어떻게 될까? A.삭제된 상태로 쓸 수 는 있고, fsync가 호출돼야 디스크에 저장된다.
        
    - 4KB 이상의 스택 공간이 필요한 사용자 프로그램을 실행하려면 어떻게 해야 하나요?
        
        스택 설정 코드를 수정하여 각 프로세스에 대해 한 페이지(4KB) 이상의 스택 공간을 할당할 수 있습니다. 다음 프로젝트에서는 더 나은 솔루션을 구현할 것입니다.
